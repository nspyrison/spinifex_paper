---
title: > 
  spinifex: An R Package for Creating a Manual Tour of Low-dimensional  Projections of Multivariate Data
author:
  - name: Nicholas Spyrison
    affiliation: Monash University 
    address:
    - Faculty of Information Technology
    email:  Nicholas.Spyrison@monash.edu
  - name: Dianne Cook
    affiliation: Monash University 
    address:
    - Department of Econometrics and Business Statistics
    email:  dicook@monash.edu
abstract: >
  Dynamic low-dimensional linear projections of multivariate data collectively known as **tours** provide an important tool for exploring multivariate data and models. The R package \pkg{tourr} provides functions for several types of tours: grand, guided, little, local and frozen. Each of these can be viewed dynamically, or saved into a data object for animation. This paper describes a new package, \pkg{spinifex}, to provide a manual tour, that allows the coefficient for a single variable to be controlled. The variable is rotated fully into the projection with a coefficient of 1 or -1, or completely out of the projection with a coefficient of 0. The resulting sequence of projections can be displayed using animation, with functions from either the \pkg{plotly} and \pkg{gganimate} packages. By varying the coefficient of a single variable, it is possible to explore the sensitivity of structure in the projection to that variable. It is particularly useful when used with a projection pursuit guided tour to simplify and understand the solution. The use of the manual tour is illustrated using a problem from particle physics.

keywords: exploratory data analysis, projection pursuit, high dimensional data, data visualization, statistical graphics, data science
preamble: >
  % preamble packages
link-citations: true
fig_caption: yes
toc: false
bibliography: spinifex_paper.bib
output: rticles::rjournal_article
  #bookdown::pdf_book:
   # base_format: rticles::rjournal_article #see sandbox for hard code solution.
---
\bibliography{spinifex_paper}
<!-- note that Di/Ursula have different setup and options and use static images.  -->
```{r setup_paper, include=FALSE}
knitr::opts_chunk$set(
  fig.align = "center", echo = TRUE, collapse = TRUE,
  message = FALSE, warning = FALSE, error = FALSE,
  cache = F, cache.lazy = FALSE
)
library(spinifex)
library(ggplot2)
library(gridExtra)
library(dplyr)
```

```{r paperFunctions, include=FALSE}
## FUNCTION FOR STATIC OUTPPUT, 
# going to facets loses control of output size, simpler to just live with this.
array2static <- function(.m_tour, .data, .m_var, .cat, .mag =2.2)
{
  slides       <- array2df(array = .m_tour, data = .data)
  basis_slides <- slides$basis_slides
  data_slides  <- slides$data_slides
  n_slides     <- max(basis_slides$slide)
  if (n_slides != 15) 
    stop(paste0("stop: n_slides !=15 !!!!! n_slides = ", n_slides))
  
  # Initialize
  ## manip var asethetics
  p             <- nrow(basis_slides) / n_slides
  col_v         <- rep("grey80", p)
  col_v[.m_var] <- "blue"
  col_v         <- rep(col_v, n_slides)
  siz_v         <- rep(0.3, p)
  siz_v[.m_var] <- 1
  siz_v         <- rep(siz_v, n_slides)
  cat           <- rep(as.factor(.cat), n_slides)

  ## circle
  angle <- seq(0, 2 * pi, length = 180)
  circ  <- data.frame(c_x = cos(angle), c_y = sin(angle))
  circ[nrow(circ)+1, ] <- NA
  ## data asethetics
  data_slides <- data.frame(data_slides, cat = rep(.cat, n_slides))
  
  grid_b <- grid_t <-
    data.frame(slide = 1:n_slides, 
               x = .mag*rep(1:5, 3), y = .mag*rep(3:1, each = 5))
  grid_t$y <- grid_t$y + max(grid_t$y)
  # OUTER JOIN
  basis_grid <- merge(x = basis_slides, y = grid_t, by = "slide", all = TRUE)
  # CROSS JOIN
  circ_grid  <- merge(x = circ, y = grid_t, by = NULL)
  # OUTER JOIN
  data_grid  <- merge(x = data_slides, y = grid_b, by = "slide", all = TRUE)
  
  # BASIS
  gg1 <-
    ggplot(data = basis_grid) +
    # AXES LINE SEGMETNS
    geom_segment(aes(x = V1 + x, y = V2 + y, xend = x, yend = y),
                 color = col_v, size = siz_v) +
    # AXES TEXT LABELS
    geom_text(aes(x = V1 + x, y = V2 + y, label = lab_abbr),
              color = col_v, vjust = "outward", hjust = "outward") +
    # AXES FRAME NUM
    geom_text(aes(x = x - .7, y = y + 1.1, 
                  label = paste0("frame: ",slide)), color = "grey50") +
    # AXES CIRCLE PATH
    suppressWarnings( # Suppress for "Removed 1 rows containing missing values."
      geom_path(data = circ_grid, color = "grey80",
                mapping = aes(x = x+c_x, y = y+c_y))
    )
  
  # PROJECTION
  gg2 <- gg1 +
    # PROJ DATA POINTS
    geom_point(data = data_grid, size = .7,
               mapping = aes(x = V1 + x, y = V2 + y, color = cat),
               shape = as.integer(cat) + 15) +
    # PROJ DATA FRAME NUM
    geom_text(data = data_grid, color = "grey50",
              mapping = aes(x = x - .7, y = y + 1.1, 
                            label = paste0("frame: ",slide))) +
    theme_void() +
    scale_color_brewer(palette = "Dark2") + 
    # coord_fixed() +
    theme(legend.position="none",
          panel.border = element_rect(colour = "black", fill = NA))
  
  gg2
}

view_basis2 <- function(basis, labels = paste0("V", 1:nrow(basis)),
                        manip_var, data = NULL, axes = "center"){
  basis <- as.data.frame(basis)
  angle <- seq(0, 2 * pi, length = 360)
  circ <- data.frame(x = cos(angle), y = sin(angle))
  zero <- set_axes_position(0, axes)
  basis <- set_axes_position(basis, axes)
  circ <- set_axes_position(circ, axes)
  col <- rep("black", nrow(basis))
  col[manip_var] <- "blue"
  
  gg <- ggplot2::ggplot() + ggplot2::scale_color_brewer(palette = "Dark2") + 
    ggplot2::theme_void() + ggplot2::theme(legend.position = "none") + 
    ggplot2::coord_fixed()
  if (axes != "off") {
    gg <- gg + ggplot2::geom_path(
      data = circ, mapping = ggplot2::aes(x = x, y = y), 
      color = "grey80", size = 0.3, inherit.aes = F) + 
      ggplot2::geom_segment(
        data = basis, mapping = ggplot2::aes(x = V1, y = V2, xend = zero, yend = zero), color = col) + 
      ggplot2::geom_text(
        data = basis, mapping = ggplot2::aes(x = V1, y = V2, label = labels), 
        size = 4, color = col, hjust = 1.1, vjust=.4)
  }
  if (!is.null(data)) {
        proj <- as.data.frame(tourr::rescale(as.matrix(data) %*% 
            as.matrix(basis)) - 0.5)
        gg <- gg + ggplot2::geom_point(data = proj, mapping = ggplot2::aes(x = V1, 
            y = V2))
    }
    gg
}

view_manip_space2 <- function (basis,
                               manip_var,
                               manip_col = "blue",
                               tilt = pi *
                                 5 / 12,
                               z_col = "red",
                               labels = paste0("V", 1:nrow(basis)))
{
    find_angle <-
      function(a, b)
        acos(sum(a * b) / (sqrt(sum(a * a)) * sqrt(sum(b * b))) )
    make_curve <-
      function(ang_st = 0,
               ang_stop = 2 * pi) {
        # angle is atan(y/x)
        angle <- seq(ang_st, ang_stop,
                     length = round(360 / (2 * pi) * abs(ang_st - ang_stop)) )
        data.frame(x = cos(angle), y = sin(angle), z = sin(angle))
      }
    xyz <- function(x) { colnames(x)<-c("x","y","z");x }

    p <- nrow(basis)
    col_v <- rep("grey80", p)
    col_v[manip_var] <- manip_col
    siz_v <- rep(0.3, p)
    siz_v[manip_var] <- 1

    circ_r <- make_curve() %>%
      mutate( y=y*cos(tilt), z=z*sin(tilt))
    m_sp   <- xyz(as.data.frame(create_manip_space(basis, manip_var)))
    m_sp_r <- m_sp %>% mutate( y=y*cos(tilt), z=z*sin(tilt))
    mvar   <- m_sp[manip_var, ]
    mvar_r <- m_sp_r[manip_var, ]

    phi_ang     <- find_angle(c(m_sp_r$x, m_sp_r$y), c(m_sp_r$x, m_sp_r$z))
    phi_offset  <- find_angle(c(mvar_r$x, mvar_r$y), c(1,0))
    phi_curve_r <- .4*make_curve(ang_st = phi_offset, ang_stop = phi_ang) %>%
      mutate( y=y*cos(tilt), z=z*sin(tilt))

    thata_ang     <- find_angle(c(mvar$x, mvar$y),c(1, 0))
    theta_curve_r <- .5*make_curve(ang_st = 0, ang_stop = thata_ang) %>%
      mutate( y=y*cos(tilt), z=z*sin(tilt))

    gg <-
      ggplot2::ggplot() + ggplot2::scale_color_brewer(palette = "Dark2") +
      ggplot2::theme_void() + ggplot2::theme(legend.position = "none") +
      ggplot2::coord_fixed() +
        ggplot2::geom_path(data = circ_r,
                           mapping = ggplot2::aes(x = x, y = y),
                           color = manip_col,
                           size = 0.3,
                           inherit.aes = F
        ) +
        #projection plane:
        ggplot2::geom_segment(data = m_sp_r,
                              mapping = ggplot2::aes(
                                x = x,
                                y = y,
                                xend = 0,
                                yend = 0
                              ),
                              size = siz_v,
                              colour = col_v
        ) +
        ggplot2::geom_text(data = m_sp_r,
                           mapping = ggplot2::aes(x = x, y = y, label = labels),
                           size = 4,
                           colour = col_v,
                           vjust = "outward",
                           hjust = "outward"
        ) +
        #Z direction
        ggplot2::geom_path(data = circ_r,
                           mapping = ggplot2::aes(x = x, y = z),
                           color = z_col,
                           size = 0.3,
                           inherit.aes = F
        ) +
        ggplot2::geom_segment(data = mvar_r,
                              mapping = ggplot2::aes(x = x,y = z,
                                                     xend = 0,yend = 0),
                              size = 1,
                              colour = z_col
        ) +
        ggplot2::geom_segment(data = mvar_r,
                              mapping = ggplot2::aes(x = x, y = z,
                                                     xend = x,yend = y),
                              size = 0.3,
                              colour = "grey80",
                              linetype = 2
        ) +
        ggplot2::geom_text(data = mvar_r,
                           mapping = ggplot2::aes(x = x, y = z, label = labels[manip_var]),
                           size = 4,
                           colour = z_col,
                           vjust = "outward",
                           hjust = "outward"
        ) +
        # label angles
        geom_path(data = phi_curve_r,
                  mapping = aes(x=x, y=z),
                  color = z_col,
                  size = 0.2
        ) +
        geom_text(data = 1.2 * phi_curve_r[ceiling(nrow(phi_curve_r)/2), ],
                  mapping = ggplot2::aes(x=x, y=z, label = "phi"),
                  color = z_col,
                  parse = T,
                  size = 4
        ) +
        geom_path(data = theta_curve_r,
                  mapping = aes(x, y),
                  color = manip_col,
                  size = 0.2
        ) +
        geom_text(data = 1.2 * theta_curve_r[ceiling(nrow(theta_curve_r)/2), ],
                  mapping = ggplot2::aes(x=x, y=y-.02, label = "theta"),
                  color = manip_col,
                  parse = T,
                  size = 4
        )
    gg
  }
```


# Introduction

<!-- Tours -->
Exploring multivariate spaces is a challenging task, increasingly so as dimensionality increases. Traditionally, static low-dimensional projections are used to display multivariate data in two dimensions, such as principal component analysis, linear discriminant spaces or projection pursuit. These are useful for finding relationships between multiple variables, but they are limited because they show only a glimpse of the high-dimensional space. An alternative approach is to use a tour of dynamic linear projections, to look at many different low-dimensional projections. Tours can be considered to extend the dimensionality of visualization, which is important as data and models exist in more than 3D. The package \CRANpkg{tourr} [@wickham_tourr_2011] provides a platform for generating tours. It has many types of tours available, and many types of displays possible. A user can make a grand, guided, little, local or frozen tour, and display the resulting projected data as a scatterplot, density plot, histogram, or even as Chernoff faces if the projection dimension is more than 3.  

<!-- Manual tour -->
This work adds a manual tour to the collection. The manual tour was described in @cook_manual_1997 and allows a user to control the projection coefficients of a selected variable in a 2D projection. The manipulation of these coefficients allows the analyst to explore their sensitivity to the structure within the projection. As manual tours operate on only one variable at a time, they are particularly useful once a feature of interest has been identified. 

<!-- interesting features and guided tours -->
One way to identify "interesting" features is with the use of a guided tour [@cook_grand_1995]. Guided tours select a very specific path, which approaches a projection that optimizes an objective-function. The optimization is conducted in a manner similar to simulated annealing [@kirkpatrick_optimization_1983]. The direct optimization of a function allows guided tours to rapidly identify interesting projection features given the relatively large parameter-space. After a projection of interest is identified an analyst can then use the "finer brush" of the manual tour, by controlling the contributions of individual variables to explore the sensitivity they have on the structure visible in the projection.

<!-- Paper outline -->
The paper is organized as follows. Section \ref{sec:algorithm} describes the algorithm used to perform a radial manual tour as implemented in the package \CRANpkg{spinifex}. Section \ref{sec:display} explains how to generate an animation of the manual tour using the animation frameworks offered by \CRANpkg{plotly} [@sievert_plotly_2018] and \CRANpkg{gganimate} [@pedersen_gganimate:_2019]. Package functionality and code usage following the order applied in the algorithm follows in section \ref{sec:usage}. Section \ref{sec:application} illustrates how this can be used for sensitivity analysis applied to multivariate data collected on high energy physics experiments [@wang_mapping_2018]. Section \ref{sec:discussion} summarizes this paper and discusses potential future directions.


<!-- Algorithm outline -->
# Algorithm {#sec:algorithm}

The algorithm to conduct a manual tour interactively, by recording mouse/cursor motion, is described in detail in @cook_manual_1997. Movement can be in any direction and magnitude, but it can also be constrained in several ways:

- *radial*: fix the direction of contribution, and allow the magnitude to change.
- *angular*: fix the magnitude, and allow the angle or direction of the contribution to vary.
- *horizontal*, *vertical*: allow rotation only around the horizontal or vertical axis of the current 2D projection.

The algorithm described here produces a **radial** tour as an *animation sequence*. It takes the current contribution of the chosen variable, and using rotation brings this variable fully into the projection, completely removes it, and then returns to the original position. This is an overview of the steps:

1. Provided with a 2D projection, choose a variable to manipulate. This is called the "manip var".
2. Create a 3D manipulation space, where the manip variable has the full contribution.
3. Generate a rotation sequence which increases the norm of the coefficient to 1 and zeros it.

More detail is provided in the following sections. Function names are provided, but code structure and usage is discussed in section \ref{sec:usage}.

## Notation

The notation used to describe the algorithm for a 2D radial manual tour is as follows:

- $\textbf{X}$, the data, an $n \times p$ numeric matrix to be projected to 2D.
- $\textbf{B} = (B_1,~ B_2)$, any 2D orthonormal projection basis, $p \times 2$ matrix, describing the projection from $p$ to two dimensions. We will call this the "original projection" because it is the starting point for the manual tour.
- $k$, is the index of the variable to manipulate, called the "manip var".
- $|\textbf{B}_k|$, the norm of the manip var, $k$
<!-- - $\textbf{B}_k$, the manipulation variable (manip var), the variable whoes contribution will be controled. -->
- $\textbf{e}$, a 1D coordinate basis vector of length $p$ with the $k$-th element set to one. 
- $\theta$, the angle of in-projection-plane rotation, for example, on the reference axes; $c_\theta, s_\theta$ are the cosine and sine.
- $\phi$, the angle of out-of-projection-plane rotation, into the manipulation space; $c_\phi, s_\phi$ are the cosine and sine.
- $\textbf{U}$ is the axis of rotation for $\phi$.

<!-- operate on bases -->
The algorithm operates entirely on projection bases and utilizes the data only later when making a display. <!--The projection space can be viewed at any point in the process by pre-multiplying the data and plotting the first two variables.-->

## Steps
### Step 0) Set up

<!-- describe data. -->
The flea data, originally from @lubischew_use_1962, made available in \pkg{tourr} is used to illustrate the algorithm. The data contains 74 observations across 6 variables, which are physical measurements of the flea beetles. Each observation belongs to one of three species.

<!-- Projection basis -->
An initial 2D projection basis set must be provided. One way to identify a projection containing interesting features is to apply a guided tour. In a guided tour, the projection sequence is selected by optimizing an index function via hill-climbing on the projection space. In this case, the holes index is selected and applied to the standardized flea data. The holes index is maximized when the projected observations are furthest from the center. Figure \ref{fig:step0} shows a locally optimized projection of the data. The left panel displays the reference axes of the projection basis, a visual indication of the magnitude and direction each variable contributes to the projection. The right panel shows the data as projected through the basis set described by the reference axes (left). Data points are colored and given shape according to the species.

Call \code{view\_basis()} on a basis to produce a \CRANpkg{ggplot2} [@wickham_ggplot2:_2016] graphic similar to Figure \ref{fig:step0}. The projected data is processed for display using matrix multiplication $\textbf{X}_{[n,~p]} ~*~ \textbf{B}_{[p,~d]} ~=~ \textbf{P}_{[n,~d]}$.


```{r step0, echo=F, results='hide', out.width='70%',                             fig.cap = "Initial 2D projection: representation of the basis  (left) and resulting data projection (right) of standardized flea data. The color and shape of data points are mapped to beetle species. The basis was identified using a projection pursuit guided tour, with the holes index. The contribution of the variables aede2 and tars1 approximately contrasts the other variables. The visible structure in the projection are the three clusters corresponding to the three species."}
## Flea holes tour
set.seed(20190425)
f_dat  <- tourr::rescale(flea[,1:6])
f_cat  <- factor(flea$species)
f_path <- save_history(f_dat, guided_tour(holes()))
f_bas  <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2)
f_mvar <- 5
f_msp  <- create_manip_space(basis = f_bas, manip_var = f_mvar)
f_proj <- data.frame(tourr::rescale(f_dat %*% f_msp[, 1:2]))

# step0, output
# Adjust centering to make axes and data side by side
view_basis(f_bas, labels = colnames(f_dat)) +
  geom_point(data = f_proj,
             mapping = aes(x = X1 + .75, y = X2 - .5, color = f_cat),
             pch = as.integer(f_cat) + 15) +
  theme(panel.border = element_rect(colour = "black", fill = NA))
```


### Step 1) Choose manip variable

<!-- select a manip var-->
In Figure \ref{fig:step0} the contribution of the variables tars1 and aede2 mostly contrast the contribution of the other four variables. These two variables combined contribute in the direction of the projection where the purple cluster is separated from the other two clusters. The variable aede2 is selected as the manip var, the variable to be controlled in the tour. The question that will be explored is how important this variable is to the separation of the clusters.


### Step 2) Create the 3D manip space

<!-- Zero Vect, manip sp -->
Initialize the coordinate basis vector as a zero vector $\textbf{e}$ of length $p$, and set the $k$-th element to 1. In the example data, aede2 is the fifth variable in the data, so $k=5$, set $e_5=1$ . Use a Gram-Schmidt process to orthonormalize the coordinate basis vector on the original 2D projection to describe a 3D manipulation space, $\textbf{M}$.

\begin{align*}
  e_k &\leftarrow 1 \\ 
  \textbf{e}^*   &\leftarrow \textbf{e} - \langle \textbf{e}, \textbf{B}_1 \rangle \textbf{B}_1 - \langle \textbf{e}, \textbf{B}_2 \rangle \textbf{B}_2 \\ 
  \textbf{M}_{[p,~3]} &= (\textbf{B}_1,\textbf{B}_2,\textbf{e}^*)
\end{align*}

<!-- What the manip space facilitates -->
The manip space provides a 3D projection from $p$-dimensional space, where the coefficient of the manip var can range completely between [-1, 1]. 3D rotation can be used to rotate the mani variable completely into or completely out of a 2D projection. Figure \ref{fig:step2} illustrates this 3D manipulation space with the manip var highlighted. This representation is produced by calling the \code{view\_manip\_space()} function. Functionally, the manipulation space is more of a mathematical construct that needn't be visualized but this diagram provides intuition for the technique.

```{r step2, echo=F, out.width='70%',                                           fig.cap = "Illustration of a 3D manipulation space, constructed to change the contribution of the variable aede2 in the example data. The red circle indicates a unit sphere. The 2D projection is represented by the blue circle, with the projection coefficients represented by grey lines and text. The manip var axis, in red, has length 1 touching the sphere, extends the projection to a third dimension. The shadow of this axis (blue) is its contribution in the original 2D projection."}
view_manip_space2(basis = f_bas, manip_var = f_mvar, labels = colnames(f_dat)) +
    theme(panel.border = element_rect(colour = "black", fill = NA))
```

```{r step3, echo=F, warning=F, fig.height=2, fig.width=8, out.width='100%',  fig.cap = "Snapshots of a radial manual tour manipulating aede2: (1) original projection, (2) full contribution, (3) zero contribution, (4) back to original. "}
f_angle <- .26
f_mtour <- manual_tour(f_bas, manip_var = f_mvar, angle = f_angle)
if(dim(f_mtour)[3] != 15) message(
  paste0("!!!!! step3 n_slides != 15 !!!!! Please knit again. n_slides = ", dim(f_mtour)[3]))
p1 <- view_basis2(f_mtour[,,1],  colnames(f_dat), manip_var = f_mvar) + ggtitle("1")
p2 <- view_basis2(f_mtour[,,6],  colnames(f_dat), manip_var = f_mvar) + ggtitle("2")
p3 <- view_basis2(f_mtour[,,12], colnames(f_dat), manip_var = f_mvar) + ggtitle("3")
p4 <- view_basis2(f_mtour[,,15], colnames(f_dat), manip_var = f_mvar) + ggtitle("4")
grid.arrange(p1, p2, p3, p4, ncol=4)
```

### Step 3) Generate rotation

<!-- illustration of axis manip -->
Imagine holding the manip var, the red axis in Figure \ref{fig:step2}, one end fixed to the origin and moving it like a lever. This is effectively the process of the radial manual to rotate the manip variable into and out of the 2D projection (Figure \ref{fig:step3}). As the variable is controlled, the manipulation space rotates about the origin, the projection onto the horizontal projection plane correspondingly moves. This is what happens in a manual tour. Generating a sequence of values for the horizontal and vertical, angles produces a path for the rotation of the manipulation space. This defines the (orthonormally-constrained) rotation on the basis coefficients.

<!-- describe manip var path -->
For a radial tour fix the (horizontal) angle within the projection plane, $\theta$, and define a sequence for the (vertical) angle coming out of the projection plane, $\phi$, bringing the initial $XY$ contributions of the manip var to a maximum and then to zero before returning to the initial position. Alternatively, for an oblique manual tour, capture the user manipulation directly on the $XY$ of the projection plane.

<!-- define the rotation matrix -->
Rotations are defined by the axes they pivot on, $\theta$ then is the rotation around the $Z$ axis. While $\phi$ will be the rotation around, $\textbf{U}$, a new axis on the $XY$ plane, orthogonal to $\phi$. Given these axes, the SO(3) rotation matrix can be derived by the following.

\begin{align*}
  \textbf{U} &= (u_x, u_y, u_z) =
  (s_\theta, -c_\theta, 0) \\ 
  &=
  \begin{bmatrix}
  0 & -u_z & u_y  \\
  u_z & 0 & -u_x \\
  -u_y & u_x & 0 \\
  \end{bmatrix} =
  \begin{bmatrix}
    0 & 0 & -c_\theta \\
    0 & 0 & -s_\theta \\
    c_\theta & s_\theta & 0 \\
  \end{bmatrix} \\
  \end{align*}
Apply Rodrigues' rotation formula{@rodrigues_lois_1840}:
  \begin{align*}
    \textbf{R}_{[3,~3]} 
    &= \textbf{I}_3 + s_\phi\*\textbf{U} + (1-c_\phi)\*\textbf{U}^2 \\
        &=
    \begin{bmatrix}
      1&0&0 \\ 
      0&1&0 \\ 
      0&0&1 \\
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & c_\theta s_\phi \\
      0 & 0 & s_\theta s_\phi \\
      -c_\theta s_\phi & -s_\theta s_\phi & 0 \\
    \end{bmatrix} +
    \begin{bmatrix}
      -c_\theta (1-c_\phi) & s^2_\theta (1-c_\phi) & 0 \\
      -c_\theta s_\theta (1-c_\phi) & -s^2_\theta (1-c_\phi) & 0 \\
      0 & 0 & c_\phi-1 \\
    \end{bmatrix} \\
    &= 
    \begin{bmatrix}
      c_\theta^2 c_\phi + s_\theta^2 &
      -c_\theta s_\theta (1 - c_\phi) &
      -c_\theta s_\phi \\
      -c_\theta s_\theta (1 - c_\phi) &
      s_\theta^2 c_\phi + c_\theta^2 &
      -s_\theta s_\phi \\
      c_\theta s_\phi &
      s_\theta s_\phi &
      c_\phi
    \end{bmatrix} \\
\end{align*}
<!-- The term $(1-c_\phi)$ is used by convention, but $2sin^2(\phi/2)$ is more computationally robust. -->

<!-- rotate manip space -->
Defining the axis of rotation for $\phi$ and the application of Rogrigues' rotation formula results in the rotation matrix, the rotation group SO(3). Continue with the rotation of the manipulation space, post-multiply the space by the above rotation matrix producing **RM**, the rotated manip space. This is basis values, the linear combination of variables, for one frame of the animation, repeat this process over a number of values of $\phi$ to produce an animation.


**For each value of ** $\phi_i$ **:**
<!-- don't mix rmd and latex... -->

\begin{align*}
  \textbf{RM}_{[p,~3,~i]} &= \textbf{M}_{[p,~3]} ~*~ \textbf{R}_{[3,~3,~i]} 
\end{align*}

## Creating the animation

<!--  phi transform and animation -->
The steps outlined above can be used to create any arbitrary rotation in the manip space. To use these for sensitivity analysis, the radial rotation is built into an animation where the manip variable is rotated fully into the projection, completely out, and then back to the start. This involves changing $\phi$, the angle relative to its initial value. 

When $\phi$ is 0, the manip var is completely in the projection, and when $\phi$ is $\pi$, $\textbf{X}_k$ is not contributing at all. 

### Sequence of $\phi_i$

1. Set initial value to be $\phi_1$.
2. Set an angle value ($\Delta_\phi$) that sets the step size to make in rotating the manip var into and out of the projection. (Note: Using angle value to control this is consistent with the tour algorithm, as implemented in the \CRANpkg{tourr}).
3. Step towards $0$, where the manip var has a completely in the projection.
4. Step towards $\pi/2$ where the manip variable has no contribution.
5. Step back to $\phi_1$.

In each of steps 3-5, a small step may be made to bring it exactly to the end position. 

### Checks that need to be made

find the transformation $\phi_i$ - $\phi_1$ useful to think about $\phi$ relative to the basis plane. Additionally, the value of $\phi$ may be out of phase by a factor of pi. If the manip variable doesn't move as expected these are the first places to check.

<!-- description of slides, on the technical side we haven't gone back to data space yet. -->
Figure \ref{fig:step4} illustrates a sequence with 15 projected bases, showing the reference axes on the top half with the corresponding projected data points below. Changes in the basis coefficients of the manip var correspond to the distance separating the purple cluster and the remaining sample, aede2 is crucial in distinguishing the variation of species. Tours are typically viewed as an animation. The animation of this tour can be viewed online at https://nspyrison.netlify.com/thesis/flea_manualtour_mvar5/. The page may take a moment to load. Animations can be produced using the function \code{play\_manual\_tour()}.

<!-- step3 caption -->
```{r step4, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                                                fig.cap = "Radial manual tour manipulating aede2 of standardized flea data.  The contributions increase from its initial contribution to a full contribution to the projection before decreasing to zero and then returning to its initial value. Manipulating the coefficeients of aede2 changes the distance separating the purple cluster. This shows that aede2 is important for distinguishing this species from the ramaining data. An animated version can be viewed at  https://nspyrison.netlify.com/thesis/flea\\_manualtour\\_mvar5/."}
#play_manual_tour(f_dat, f_bas, f_mvar, col = f_cat, angle = f_angle)
array2static(.m_tour = f_mtour, .data = f_dat, .m_var = f_mvar, .cat = f_cat)
```


## Data in projection-space {#sec:display}

<!-- the reminder of basis operation and now apply data -->
In an appeal to performance, the operations of a tour are performed on the bases while the larger datasets are not operated on until the display of data points are needed. After the bases are brought into the projection-space, however, it is helpful to observe them with projected data in the same space. Pre-multiply the data by basis frame bringing the data into the projection space.

\begin{align*}
  \textbf{P}_{[n,~3]} &= \textbf{X}_{[n,~p]} ~*~ \textbf{RM}_{[p,~3]}
\end{align*}

<!-- plot 2 var in seq for animation -->
For a 2D scatterplot, plot the first two variables within each frame. Show each frame in sequence to form an animation. The remaining manipulation space variable can be linked to point aesthetic (such as size or color) to produce depth cues used in conjunction with the $XY$ scatterplot.

# Package structure and functionality {#sec:usage}

This section discusses the functions and code usage of the package before delving into a domain-specific application of the manual tour.

## Installation

<!-- step 0 disp code. -->
```{r installCODEEXAMPLE, eval=F, echo=T}
# remotes::install_github("nspyrison/spinifex") # Development version
install.package("spinifex")
library("spinifex")

# Also see the vignette: 
vignette("spinifex_vignette")
```

## Primary package functions 
<!-- in terms of work flow. -->

The primary functions that will aid users in performing their own manual tours are broken into the following groupings: tour preparation, tour animation, and utility.

```{r functionsTable, echo=F}
library(kableExtra)

funcs <- rbind(
  c("tour preparation", "view_basis", "displays the reference frame of the basis"),
  c("tour preparation", "view_manip_space", "displays the manipulation space"),
  c("tour animation", "play_tour_path", "animates given tour path"),
  c("tour animation", "play_manual_tour", "animates the manual tour algorithm"),
  # c("utility", "col_of", "maps a variable to the point color"),
  # c("utility", "pch_of", "maps a variable to the point character (shape)"),
  c("utility", "render_gganimate", "uses gganimate to render the animation"),
  c("utility", "render_plotly", "uses plotly to render the animation")
)
colnames(funcs) <- c("Class", "Function", "Description")
  
kable(funcs, "latex", caption = "Primary functions", booktabs = T)
```

In the following section describes and demonstrates the usage of the above functions following the order in the algorithm. The utility functions are called by the tour animation functions, passed to the argument \code{render\_type}. Usage is demonstrated below and in the example documentation.


## Algorithm code

We'll start by initializing values including a standardized data set (numeric columns only), a starting basis, a categorical variable for point aesthetics (optional), and a manip var. To get bearings on the projection, start by observing the reference axes of the basis with \code{view\_basis()} producing Figure \ref{fig:step0}.

<!-- setup -->
```{r step0CODEEXAMPLE, eval=F, echo=T}
f_data  <- tourr::rescale(flea[, 1:6])                    ## standardize data
f_path  <- save_history(f_data, guided_tour(holes()))     ## produce guided tour
f_basis <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2) ## end of guided tour
f_cat   <- factor(flea$species)                           ## categorical var

view_basis(basis = f_basis, 
           data = f_data,
           labels = colnames(f_data))
```

After becoming familiar with this space, select a manip var, the variable to change the contributions of. Use \code{view\_manip\_space()} to view the new space with a dimension orthogonal to the projection plane where the manip var has a full contribution. This illustrates how the manip var is manipulated with the addition of the manipulation space as shown in Figure \ref{fig:step2}.

<!-- step 2 disp code. -->
```{r step2CODEEXAMPLE, eval=F, echo=T}
f_mvar  <- 5  ## manip var number

view_manip_space(basis = f_basis, 
                 manip_var = f_mvar, 
                 labels = colnames(f_data))
```

Now we are ready to perform a manual tour on the selected variable. Use \code{play\_manual\_tour()} to perform the algorithm as discussed above, in section \ref{sec:algorithm}. This is the animated equivalent of Figure \ref{fig:step3}. 

<!-- step 3 disp code. -->
```{r step3CODEEXAMPLE, eval=F, echo=T}
angle_speed <- .26

play_manual_tour(data = f_data,
                 basis = f_basis, 
                 manip_var = f_mvar, 
                 angle = angle_speed,
                 col = f_cat,
                 pch = f_cat)
```

This concludes the content of the algorithm section, however, lets cover animating paths generated in \pkg{tourr}. Animate the previously generated guided tour path via \code{play\_tour\_path()}. Utility functions can also be passed as arguments into either of the tour animation function to change the resulting graphics object, set \code{render\_type = render\_gganimate} to view the animation as a GIF.

```{r guidedTourCODEEXAMPLE, eval=F, echo=T}
play_tour_path(tour_path = f_path,
               data = f_data,
               render_type = render_gganimate, 
               angle = angle_speed
)
```


## Rendering and sharing

The \pkg{tourr} package utilizes \pkg{base} graphics for the display of tours. \pkg{spinifex} allows tours to be rendered in \pkg{plotly} as an HTML5 object or \pkg{gganimate} as GIF or MP4 files. Sharing of animations is not trivial, especially static formats like print and PDF. Even with dynamic display capturing the correct resolution and aspect ratio can be challenging, while many formats quickly bloat file sizes limiting sharing options. Keep in mind hosting options and exporting functions offered in \pkg{plotly}, \pkg{gganimate} and \pkg{tourr}.


## Storage

Storing each data point for every frame of the animation is redundant. Just as operations are performed on the bases, so too should tour paths be stored as bases and a single instance of the data. Consider a radial manual tour, we can store the salient features in 3 bases, where $\phi$ is at its starting, minimum, and maximum values. The frames in between can be interpolated by supplying angular speed. With the use of the \code{tourr::save\_history()} function, the target bases can be saved. From there geodesic interpolation can be used to populate the intermittent frames. This type of interpolation should not be used on manual tours, which have already been initialized into a 3D manipulation space where direct linear interpolation is appropriate.


# Application {#sec:application}

<!-- Introduction of data and original paper -->
In a recent paper, @wang_mapping_2018, the authors aggregate and visualize the sensitivity of hadronic experiments to nucleon structure. The authors introduce a new tool, PDFSense, to aid in the visualization of parton distribution functions (PDF). The parameter-space of these experiments lies in 56 dimensions, $\delta \in \mathbb{R}^{56}$, and are visualized as 3D subspaces of the 10 first principal components in linear (PCA) and non-linear (t-SNE) embeddings. 

<!-- grand tours on the same data -->
Using the same data, another study, @cook_dynamical_2018, applied grand tours [@asimov_grand_1985] to the same subspaces. Grand tours are dynamic linear projections of high dimensional spaces where basis sets are selected at random and animated with geodesic interpolation of the intermediate frames. Because of the change in the basis, or orientation to the subspace, tours are able to better resolve the distribution shape of clusters, intra-cluster detail, and better outlier detection than the use of PDFSense & TFEP (TensorFlow embedded projections) or traditional static embeddings. Before applying manual tours the structure of the data is discussed.

<!-- Data structure -->
The data has a hierarchical structure with top-level clusters; DIS, VBP, and jet. Each cluster is a particular class of experiments, each with many experimental datasets which, in turn, have many observations. In consideration of data density, we conduct manual tours on subsets of the DIS and jet clusters. This explores the sensitivity of the structure to each of the variables in turn and we present the subjectively best and worst variable to manipulate for identifying dimensionality of the clusters and describing the span of the clusters.


## Jet cluster

<!-- jet cluster, explain dimensionality -->
The jet cluster resides in a smaller dimensionality than the full set of experiments with four principal components explaining 95% of the variation in the cluster [@cook_dynamical_2018]. The data within this 4D embedding is subset down to ATLAS7old and ATLAS7new to focus in on two groups with a reasonable number of observations that occupy different parts of the subspace. Radial manual tours controlling contributions from PC4 and PC3 are shown in Figure \ref{fig:JetClusterGood} and Figure \ref{fig:JetClusterBad} respectively. These variables are selected to contrast the information conveyed by different manip variables. Links to dynamic HTML5 animations controlling each of the four variables are also provided. 

<!-- discussion of findings and which is more insightful -->
When manipulating PC4, there is a clear difference in the parameter space spanned by the experiment types ATLAS7new and ATLAS7old. Specifically, the variation of ATLAS7new (green) becomes more singular. The experiments are probing different parameter space and PC4 is important to demonstrate this. Yet, when PC3 is manipulated there is no clear indication that the different experiments probe different parameter space. Performing a radial manual tour on PC4 is more insightful than for PC3. Radial manual tours manipulating each of the principal components in the jet cluster can be viewed by following the links: [PC1](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc1/), [PC2](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc2/), [PC3](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc3/), and [PC4](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc4/).


```{r JetClusterGood, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                     fig.cap="A radial manual tour of PC4 within the jet cluster. Colored by experiment type: ATLAS7new in green and ATLAS7old in orange. When PC4 fully/negligibly contributes to the projection ATLAS7new (green) spans the same space as the orange points. During the intermediate frames, the ATLAS7new is compressed in the direction radial to PC4. The differece in distribution shape demonstrates the experiments probe different phase-space, which has a linear mapping back to the original variables for interpretation and further exploration. An HTML5 version can be viewed at https://nspyrison.netlify.com/thesis/jetcluster\\_manualtour\\_pc4/."}
# Jet cluster, Fig 7 of cook_dynamical_2018, subset to ATLAS7old and ATLAS7new
load("./data/JetCluster_sub.rda")
load("./data/JetCluster_basis.rda")

jet_bas   <- JetCluster_basis
jet_dat   <- tourr::rescale(JetCluster_sub[, 1:4])
jet_cat   <- factor(JetCluster_sub$exp)
jet_mvar  <- 4
jet_ang   <- .26
jet_mtour <- manual_tour(basis = jet_bas, manip_var = jet_mvar, angle = jet_ang)
#dim(jet_mtour)

array2static(.m_tour = jet_mtour, .data = jet_dat,
             .m_var = jet_mvar, .cat = jet_cat)
# play_manual_tour(data = jet_dat, basis = jet_bas, manip_var = jet_mvar,
#                  angle = jet_ang, axes = "bottomleft", col = jet_cat)

##M_VAR, RESULT
# 1, good
# 2, poor
# 3, *worst
# 4, *best
```


```{r JetClusterBad, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                       fig.cap = "A radial manual tour of PC4 within the jet cluster. Colored by experiment type: ATLAS7new in green and ATLAS7old in orange. Data from ATLAS7new (green) spans mostly the same space as ALTLAS7old (orange) with no evident difference in cluster structure across varying contributions of PC3. An HTML5 version can be viewed at https://nspyrison.netlify.com/thesis/jetcluster\\_manualtour\\_pc3/."}
# Jet cluster, Fig 7 of cook_dynalical_2018, subset to ATLAS7old and ATLAS7new
jet_mvar  <- 3
jet_mtour <- manual_tour(basis = jet_bas, manip_var = jet_mvar, angle = jet_ang)

array2static(.m_tour = jet_mtour, .data = jet_dat,
             .m_var = jet_mvar, .cat = jet_cat)
```


## DIS cluster

<!-- introduce DIS cluster -->
A different space is used to explore the DIS cluster; specifically the first six principal components, which explains 48% of the variation contained within the aggregated data [@cook_dynamical_2018]. Radial manual tours are performed on PC6 and PC2 in Figure \ref{fig:DISclusterGood} and Figure \ref{fig:DISclusterBad} respectively.

<!-- comparison of the DIS cluster -->
The selection of the manip variable is important, as the manipulation spaces convey substantially different information. The manual tour of PC6 offers information about the dimensionality, shape, and orientations of the different experiment classes. PC6 is particularly important to describe the variations of DIS HERA1+2 and charm SIDIS observations,  Whereas manipulating the contributions of PC2 only shows a subset of the dimensionality and shape information. Manipulating the contributions of PC6 turned out to be much more insightful than PC2. This result might seem counter-intuitive at first as PC2 should explain much more of the variation in the data. However, features and structures in the data regularly reside in smaller dimensionality which can be overlooked when optimizing on full sample statistics. DIS cluster manual tours manipulating each of the principal components can be viewed from the links: [PC1](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc1/), [PC2](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc2/), [PC3](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc3/), [PC4](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc4/), [PC5](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc5/), and [PC6](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc6/).


```{r DISclusterGood, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                            fig.cap = "A radial manual tour manipulating the contribution of PC6 within the DIS cluster. Points are colored by experiment type: DIS HERA1+2 in green, dimuon SIDIS in purple, and charm SIDIS in orange. The cluster DIS HERA1+2 (green) is distributed in a cross-shaped plane, charm SIDIS (orange) occupies the center space of this cross. As the contribution of PC6 becomes whole the distributions of DIS HERA1+2 (green) and charm SIDIS (orange) become singular but offset by a small angle. Less evident is the linear dimuon SIDIS (purple) observations approaching the line of view for intermediate values of PC6. An HTML5 version can be viewed at https://nspyrison.netlify.com/thesis/discluster\\_manualtour\\_pc6/."}

##DIS cluster, fig 8 of cook_dynamical_2018
load("./data/grDIScenter.rda")
load("./data/DIScluster_centered_basis.rda")
DIS_bas   <- DIScluster_centered_basis
DIS_dat   <- tourr::rescale(grDIScenter[, 1:6])
DIS_cat   <- factor(grDIScenter$disID)
DIS_mvar  <- 6
DIS_ang   <- .27
DIS_mtour <- manual_tour(basis = DIS_bas, manip_var = DIS_mvar, angle = DIS_ang)

array2static(.m_tour = DIS_mtour, .data = DIS_dat,
             .m_var = DIS_mvar, .cat = DIS_cat)
# play_manual_tour(data = DIS_dat, basis = DIS_bas, manip_var = DIS_mvar,
#                  angle = DIS_ang, axes="bottomleft", col = DIS_cat)

##M_VAR, RESULT
# 1, purple jet
# 2, *poor
# 3, black
# 4, plane
# 5, black and plane
# 6, best*purple and plane
```


```{r DISclusterBad, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                            fig.cap = "A radial manual tour manipulating the contribution of PC2 within the DIS cluster. Points are colored by experiment type: DIS HERA1+2 in green, dimuon SIDIS in purple, and charm SIDIS in orange. The plane of cross distributed DIS HERA data (green) and a nearly orthogonal jet of dimuon SIDIS (purple) is present. This jet does extend more in the plane of view when the contribution of PC2 is full, giving insight to its orientation. However, less information about the shape of DIS HERA (green) and charm SIDIS (orange) is available compared to PC6 as the manip var. An HTML5 version can be viewed at https://nspyrison.netlify.com/thesis/discluster\\_manualtour\\_pc2/."}
##DIS cluster, fig 8 of cook_dynamical_2018
DIS_mvar  <- 2
DIS_mtour <- manual_tour(basis = DIS_bas, manip_var = DIS_mvar, angle = DIS_ang)

array2static(.m_tour = DIS_mtour, .data = DIS_dat,
             .m_var = DIS_mvar, .cat = DIS_cat)
```


## Discussion {#sec:discussion}

<!-- summary of spinifex  -->
Tours, which are a dynamic linear projection of numeric multivariate data, play an important role in data visualization; they extend the dimensionality of visuals while data- and parameter-spaces become ever larger. This research has modified the algorithm producing manual tours which and has made this functionality available in package \pkg{spinifex}. The package adds to \pkg{tourr}, extending the graphics offerings that can be used to display tours.

<!-- summary of application  -->
Radial manual tours were applied to a dataset across different experiments of hadronic collisions. The importance of selecting the correct manip var, as demonstrated by comparing tours of varying amounts of structural information. Manual tours, by giving the full contribution of the manipulation space to the manip var, enable analysts to explore the sensitivity of the structure with the selected variable. This information can be used by domain experts to identify which variables are probing which parameter spaces and how sensitive those variables are to structural features. This insight can be indispensable for variable inclusion/exclusions in a model, or in high-level decisions, such as budgeting time and funding.

<!-- 3D and function vis -->
Future research on the algorithm would include extending it for use in 3D projections. The addition of another dimension theoretically allows for improved perception. In some frameworks, such as the game engine **unity**, this would allow for the exploration in immersive virtual reality or mixed reality, which may further allow for a better perception of structure and aid in higher-dimensional function visualization. Functions with many parameters suffer from the same dimensionality problem as data while their possible values lie on a surface of values rather than discrete points. Occulation, or the closer surface blocking further surfaces, will likely be an issue that may be alleviated by the use of wire mesh, changing opacity, or looking at sections of the projections known as prosections [@furnas_prosection_1994].

<!-- geometric and graphics display -->
The \pkg{tourr} package provides many other geometric displays with the \code{tourr::display\_*()} family. These geometric options could be integrated into the \pkg{ggplot2} framework for display on \pkg{plotly} and \pkg{gganimate}. Additionally, the \CRANpkg{animation} package @xie_animation:_2018 could be implemented for another graphics framework. However, \pkg{animation} builds from \pkg{base} graphics while \pkg{spinifex} utilizes \pkg{ggplot2} graphics, a significant paradigm shift, which may have  a low return on investment.

<!-- interpolation -->
The Givens rotations and Householder reflections as outlined in @buja_computational_2005 could also be added. Currently, Gram-Schmidt is the only form of frame interpolation used. In a Givens rotation, the $x$ and $y$ components (for example $\theta~= 0,~pi/2$) of the in-plane rotation are calculated separately and would be applied sequentially to produce the radial rotation. Householder reflections define reflection axes to project points on to the axes to generate rotations.

<!-- dynamic interaction/gui -->
Having script-only interaction with tours causes a significant barrier to entry. To a lesser extent, \pkg{plotly} offers some static interactions with the contained object, such as tooltips, brushing, and linking without communicating back to the R console. The development of a dynamic graphical user interface, perhaps with the use of a \CRANpkg{shiny} [@chang_shiny:_2018] application, would mitigate the barrier to entry, allow for more rapid analysis, and offer an approachable demo tool. The user could easily switch between variables to control, adjust the interpolation step angle, or flag/save specific frame basis sets. 

# Acknowledgments

This article was created in R [@r_core_team_r:_2018], using \CRANpkg{knitr} [@stodden_knitr:_2014] and \CRANpkg{rmarkdown} [@xie_r_2018], with code generating the examples inline. The source files for this article be found at [github.com/nspyrison/spinifex_paper/](https://github.com/nspyrison/spinifex_paper/). The source code for the \pkg{spinifex} package can be found at [github.com/nspyrison/spinifex/](https://github.com/nspyrison/spinifex/).


# Bibliography

