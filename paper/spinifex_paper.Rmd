---
title: > 
  spinifex: An R Package for Creating a Manual Tour of Low-dimensional  Projections of Multivariate Data
author:
  - name: Nicholas Spyrison
    affiliation: Monash University 
    address:
    - Faculty of Information Technology
    email:  nicholas.spyrison@monash.edu
  - name: Dianne Cook
    affiliation: Monash University 
    address:
    - Department of Econometrics and Business Statistics
    email:  dicook@monash.edu
abstract: >
  Dynamic low-dimensional linear projections of multivariate data collectively known as **tours** provide an important tool for exploring multivariate data and models. The R package \pkg{tourr} provides functions for several types of tours: grand, guided, little, local and frozen. Each of these can be viewed dynamically, or saved into a data object for animation. This paper describes a new package, \pkg{spinifex}, to provide a manual tour, that allows the coefficient for a single variable to be controlled. The variable is rotated fully into the projection, or completely out of the projection. The resulting sequence of projections can be displayed using animation, with functions from either the \pkg{plotly} and \pkg{gganimate} packages. By varying the coefficient of a single variable, it is possible to explore the sensitivity of structure in the projection to that variable. It is particularly useful when used with a projection pursuit guided tour to simplify and understand the solution. The use of the manual tour for studying the sensitivity of structure, in a projection, to specific variable contributions, is illustrated using particle physics data.

keywords: exploratory data analysis, projection pursuit, high dimensional data, data visualization, statistical graphics, data science
preamble: >
  % preamble packages
link-citations: true
fig_caption: yes
toc: false
bibliography: spinifex_paper.bib
output: rticles::rjournal_article
  #bookdown::pdf_book:
   # base_format: rticles::rjournal_article #see sandbox for hard code solution.
---
\bibliography{spinifex_paper}
<!-- note that Di/Ursula have different setup and options and use static images.  -->
```{r setup_paper, include=FALSE}
knitr::opts_chunk$set(
  fig.align = "center", echo = TRUE, collapse = TRUE,
  message = FALSE, warning = FALSE, error = FALSE,
  cache = F, cache.lazy = FALSE
)
library(spinifex)
library(ggplot2)
library(gridExtra)
library(dplyr)
```

```{r paperFunctions, include=FALSE}
## FUNCTION FOR STATIC OUTPPUT, 
# going to facets loses control of output size, simpler to just live with this.
array2static <- function(.m_tour, .data, .m_var, .cat, .mag =2.2)
{
  slides       <- array2df(array = .m_tour, data = .data)
  basis_slides <- slides$basis_slides
  data_slides  <- slides$data_slides
  n_slides     <- max(basis_slides$slide)
  if (n_slides != 15) 
    stop(paste0("stop: n_slides !=15 !!!!! n_slides = ", n_slides))
  
  # Initialize
  ## manip var asethetics
  p             <- nrow(basis_slides) / n_slides
  col_v         <- rep("grey80", p)
  col_v[.m_var] <- "blue"
  col_v         <- rep(col_v, n_slides)
  siz_v         <- rep(0.3, p)
  siz_v[.m_var] <- 1
  siz_v         <- rep(siz_v, n_slides)
  cat           <- rep(as.factor(.cat), n_slides)

  ## circle
  angle <- seq(0, 2 * pi, length = 180)
  circ  <- data.frame(c_x = cos(angle), c_y = sin(angle))
  circ[nrow(circ)+1, ] <- NA
  ## data asethetics
  data_slides <- data.frame(data_slides, cat = rep(.cat, n_slides))
  
  grid_b <- grid_t <-
    data.frame(slide = 1:n_slides, 
               x = .mag*rep(1:5, 3), y = .mag*rep(3:1, each = 5))
  grid_t$y <- grid_t$y + max(grid_t$y)
  # OUTER JOIN
  basis_grid <- merge(x = basis_slides, y = grid_t, by = "slide", all = TRUE)
  # CROSS JOIN
  circ_grid  <- merge(x = circ, y = grid_t, by = NULL)
  # OUTER JOIN
  data_grid  <- merge(x = data_slides, y = grid_b, by = "slide", all = TRUE)
  
  # BASIS
  gg1 <-
    ggplot(data = basis_grid) +
    # AXES LINE SEGMETNS
    geom_segment(aes(x = V1 + x, y = V2 + y, xend = x, yend = y),
                 color = col_v, size = siz_v) +
    # AXES TEXT LABELS
    geom_text(aes(x = V1 + x, y = V2 + y, label = lab_abbr),
              color = col_v, vjust = "outward", hjust = "outward") +
    # AXES FRAME NUM
    geom_text(aes(x = x - .7, y = y + 1.1, 
                  label = paste0("frame: ",slide)), color = "grey50") +
    # AXES CIRCLE PATH
    suppressWarnings( # Suppress for "Removed 1 rows containing missing values."
      geom_path(data = circ_grid, color = "grey80",
                mapping = aes(x = x+c_x, y = y+c_y))
    )
  
  # PROJECTION
  gg2 <- gg1 +
    # PROJ DATA POINTS
    geom_point(data = data_grid, size = .7,
               mapping = aes(x = V1 + x, y = V2 + y, color = cat),
               shape = as.integer(cat) + 15) +
    # PROJ DATA FRAME NUM
    geom_text(data = data_grid, color = "grey50",
              mapping = aes(x = x - .7, y = y + 1.1, 
                            label = paste0("frame: ",slide))) +
    theme_void() +
    scale_color_brewer(palette = "Dark2") + 
    # coord_fixed() +
    theme(legend.position="none",
          panel.border = element_rect(colour = "black", fill = NA))
  
  gg2
}

view_basis2 <- function(basis, labels = paste0("V", 1:nrow(basis)),
                        manip_var, data = NULL, axes = "center"){
  basis <- as.data.frame(basis)
  angle <- seq(0, 2 * pi, length = 360)
  circ <- data.frame(x = cos(angle), y = sin(angle))
  zero <- set_axes_position(0, axes)
  basis <- set_axes_position(basis, axes)
  circ <- set_axes_position(circ, axes)
  col <- rep("black", nrow(basis))
  col[manip_var] <- "blue"
  
  gg <- ggplot2::ggplot() + ggplot2::scale_color_brewer(palette = "Dark2") + 
    ggplot2::theme_void() + ggplot2::theme(legend.position = "none") + 
    ggplot2::coord_fixed()
  if (axes != "off") {
    gg <- gg + ggplot2::geom_path(
      data = circ, mapping = ggplot2::aes(x = x, y = y), 
      color = "grey80", size = 0.3, inherit.aes = F) + 
      ggplot2::geom_segment(
        data = basis, mapping = ggplot2::aes(x = V1, y = V2, xend = zero, yend = zero), color = col) + 
      ggplot2::geom_text(
        data = basis, mapping = ggplot2::aes(x = V1, y = V2, label = labels), 
        size = 4, color = col, hjust = 1.1, vjust=.4)
  }
  if (!is.null(data)) {
        proj <- as.data.frame(tourr::rescale(as.matrix(data) %*% 
            as.matrix(basis)) - 0.5)
        gg <- gg + ggplot2::geom_point(data = proj, mapping = ggplot2::aes(x = V1, 
            y = V2))
    }
    gg
}

view_manip_space2 <- function (basis,
                               manip_var,
                               manip_col = "blue",
                               tilt = pi *
                                 5 / 12,
                               z_col = "red",
                               labels = paste0("V", 1:nrow(basis)))
{
    find_angle <-
      function(a, b)
        acos(sum(a * b) / (sqrt(sum(a * a)) * sqrt(sum(b * b))) )
    make_curve <-
      function(ang_st = 0,
               ang_stop = 2 * pi) {
        # angle is atan(y/x)
        angle <- seq(ang_st, ang_stop,
                     length = round(360 / (2 * pi) * abs(ang_st - ang_stop)) )
        data.frame(x = cos(angle), y = sin(angle), z = sin(angle))
      }
    xyz <- function(x) { colnames(x)<-c("x","y","z");x }

    p <- nrow(basis)
    col_v <- rep("grey80", p)
    col_v[manip_var] <- manip_col
    siz_v <- rep(0.3, p)
    siz_v[manip_var] <- 1

    circ_r <- make_curve() %>%
      mutate( y=y*cos(tilt), z=z*sin(tilt))
    m_sp   <- xyz(as.data.frame(create_manip_space(basis, manip_var)))
    m_sp_r <- m_sp %>% mutate( y=y*cos(tilt), z=z*sin(tilt))
    mvar   <- m_sp[manip_var, ]
    mvar_r <- m_sp_r[manip_var, ]

    phi_ang     <- find_angle(c(m_sp_r$x, m_sp_r$y), c(m_sp_r$x, m_sp_r$z))
    phi_offset  <- find_angle(c(mvar_r$x, mvar_r$y), c(1,0))
    phi_curve_r <- .4*make_curve(ang_st = phi_offset, ang_stop = phi_ang) %>%
      mutate( y=y*cos(tilt), z=z*sin(tilt))

    thata_ang     <- find_angle(c(mvar$x, mvar$y),c(1, 0))
    theta_curve_r <- .5*make_curve(ang_st = 0, ang_stop = thata_ang) %>%
      mutate( y=y*cos(tilt), z=z*sin(tilt))

    gg <-
      ggplot2::ggplot() + ggplot2::scale_color_brewer(palette = "Dark2") +
      ggplot2::theme_void() + ggplot2::theme(legend.position = "none") +
      ggplot2::coord_fixed() +
        ggplot2::geom_path(data = circ_r,
                           mapping = ggplot2::aes(x = x, y = y),
                           color = manip_col,
                           size = 0.3,
                           inherit.aes = F
        ) +
        #projection plane:
        ggplot2::geom_segment(data = m_sp_r,
                              mapping = ggplot2::aes(
                                x = x,
                                y = y,
                                xend = 0,
                                yend = 0
                              ),
                              size = siz_v,
                              colour = col_v
        ) +
        ggplot2::geom_text(data = m_sp_r,
                           mapping = ggplot2::aes(x = x, y = y, label = labels),
                           size = 4,
                           colour = col_v,
                           vjust = "outward",
                           hjust = "outward"
        ) +
        #Z direction
        ggplot2::geom_path(data = circ_r,
                           mapping = ggplot2::aes(x = x, y = z),
                           color = z_col,
                           size = 0.3,
                           inherit.aes = F
        ) +
        ggplot2::geom_segment(data = mvar_r,
                              mapping = ggplot2::aes(x = x,y = z,
                                                     xend = 0,yend = 0),
                              size = 1,
                              colour = z_col
        ) +
        ggplot2::geom_segment(data = mvar_r,
                              mapping = ggplot2::aes(x = x, y = z,
                                                     xend = x,yend = y),
                              size = 0.3,
                              colour = "grey80",
                              linetype = 2
        ) +
        ggplot2::geom_text(data = mvar_r,
                           mapping = ggplot2::aes(x = x, y = z, label = labels[manip_var]),
                           size = 4,
                           colour = z_col,
                           vjust = "outward",
                           hjust = "outward"
        ) +
        # label angles
        geom_path(data = phi_curve_r,
                  mapping = aes(x=x, y=z),
                  color = z_col,
                  size = 0.2
        ) +
        geom_text(data = 1.2 * phi_curve_r[ceiling(nrow(phi_curve_r)/2), ],
                  mapping = ggplot2::aes(x=x, y=z, label = "phi"),
                  color = z_col,
                  parse = T,
                  size = 4
        ) +
        geom_path(data = theta_curve_r,
                  mapping = aes(x, y),
                  color = manip_col,
                  size = 0.2
        ) +
        geom_text(data = 1.2 * theta_curve_r[ceiling(nrow(theta_curve_r)/2), ],
                  mapping = ggplot2::aes(x=x, y=y-.02, label = "theta"),
                  color = manip_col,
                  parse = T,
                  size = 4
        )
    gg
  }
```


# Introduction

<!-- Tours -->
Exploring multivariate spaces is a challenging task, increasingly so as dimensionality increases. Traditionally, static low-dimensional projections are used to display multivariate data in two dimensions, such as principal component analysis, linear discriminant spaces or projection pursuit. These are useful for finding relationships between multiple variables, but they are limited because they show only a glimpse of the high-dimensional space. An alternative approach is to use a tour [@asimov_grand_1985] of dynamic linear projections, to look at many different low-dimensional projections. Tours can be considered to extend the dimensionality of visualization, which is important as data and models exist in more than 3D. The package \CRANpkg{tourr} [@wickham_tourr_2011] provides a platform for generating tours. It has many types of tours available, and many types of displays possible. A user can make a grand, guided, little, local or frozen tour, and display the resulting projected data as a scatterplot, density plot, histogram, or even as Chernoff faces if the projection dimension is more than 3.  

<!-- Manual tour -->
This work adds a manual tour to the collection. The manual tour was described in @cook_manual_1997 and allows a user to control the projection coefficients of a selected variable in a 2D projection. The manipulation of these coefficients allows the analyst to explore their sensitivity to the structure within the projection. As manual tours operate on only one variable at a time, they are particularly useful once a feature of interest has been identified. 

<!-- interesting features and guided tours -->
One way to identify "interesting" features is with the use of a guided tour [@cook_grand_1995]. Guided tours select a very specific path, which approaches a projection that optimizes an objective-function. The optimization is conducted in a manner similar to simulated annealing [@kirkpatrick_optimization_1983]. The direct optimization of a function allows guided tours to rapidly identify interesting projection features given the relatively large parameter-space. After a projection of interest is identified an analyst can then use the "finer brush" of the manual tour, by controlling the contributions of individual variables to explore the sensitivity they have on the structure visible in the projection.

<!-- Paper outline -->
The paper is organized as follows. Section \ref{sec:algorithm} describes the algorithm used to perform a radial manual tour as implemented in the package \CRANpkg{spinifex}. Section \ref{sec:display} explains how to generate an animation of the manual tour using the animation frameworks offered by \CRANpkg{plotly} [@sievert_plotly_2018] and \CRANpkg{gganimate} [@pedersen_gganimate:_2019]. Package functionality and code usage following the order applied in the algorithm follows in section \ref{sec:usage}. Section \ref{sec:application} illustrates how this can be used for sensitivity analysis applied to multivariate data collected on high energy physics experiments [@wang_mapping_2018]. Section \ref{sec:discussion} summarizes this paper and discusses potential future directions.


<!-- Algorithm outline -->
# Algorithm {#sec:algorithm}

The algorithm to conduct a manual tour interactively, by recording mouse/cursor motion, is described in detail in @cook_manual_1997. Movement can be in any direction and magnitude, but it can also be constrained in several ways:

- *radial*: fix the direction of contribution, and allow the magnitude to change.
- *angular*: fix the magnitude, and allow the angle or direction of the contribution to vary.
- *horizontal*, *vertical*: allow rotation only around the horizontal or vertical axis of the current 2D projection.

The algorithm described here produces a **radial** tour as an *animation sequence*. It takes the current contribution of the chosen variable, and using rotation brings this variable fully into the projection, completely removes it, and then returns to the original position. <!--This is an overview of the steps:

1. Provided with a 2D projection, choose a variable to manipulate. This is called the "manip var".
2. Create a 3D manip space, where the manip variable has the full contribution.
3. Generate a rotation sequence which increases the norm of the coefficient to 1 and zeros it.

More detail is provided in the following sections. Function names are provided, but code structure and usage is discussed in section \ref{sec:usage}.
-->

## Notation

The notation used to describe the algorithm for a 2D radial manual tour is as follows:

- $\textbf{X}$, the data, an $n \times p$ numeric matrix to be projected to 2D.
- $\textbf{B} = (B_1,~ B_2)$, any 2D orthonormal projection basis, $p \times 2$ matrix, describing the projection from $\mathbb{R}^p \Rightarrow \mathbb{R}^2$. This is called this the "original projection" because it is the starting point for the manual tour.
- $k$, is the index of the variable to manipulate, called the "manip var".
<!--- $|\textbf{B}_k|$, the norm of the manip var, $k$, the length of this basis vector between 0 and 1 inclusive.
-->
- $\textbf{e}$, a 1D basis vector of length $p$, with 1 in the $k$-th position and 0 elsewhere.
- $\textbf{M}$ is a $p \times 3$ matrix, defining the 3D subspace where data rotation occurs, and is called the manip(ulation) space. 
- $\theta$, the angle of in-projection-plane rotation, for example, on the reference axes; $c_\theta, s_\theta$ are the cosine and sine.
- $\phi$, the angle of out-of-projection-plane rotation, into the manip space; $c_\phi, s_\phi$ are the cosine and sine. The initial value for animation purposes is $\phi_1$.
- $\textbf{U}$, the axis of rotation for out-of-projection rotation.
- $\textbf{R}$, the 3D rotation matrix, for performing unconstrained 3D rotations within the manip space, $\textbf{M}$.
<!--
- $\textbf{RM} = \textbf{M} * \textbf{R}$, the result of the manip space after the application of the rotation matrix.
- $\textbf{Y} = \textbf{X} * \textbf{RM}$, the data as projected through the rotated manip space.

XXX Clean up the notation, not all of this is needed or useful. The shadow of $e$ in the projection may need some notation. The projected data should be $Y$, not $P$. 
-->

<!-- operate on bases -->
The algorithm operates entirely on projection bases and incorporates the data only when making the projected data plots.

## Steps
### Step 0) Set up

<!-- describe data. -->
The flea data (@lubischew_use_1962), available in the \pkg{tourr} package, is used to illustrate the algorithm. The data contains 74 observations on 6 variables, which are physical measurements made on beetles. Each observation belongs to one of three species.

<!-- Projection basis -->
An initial 2D projection basis must be provided. A suggested way to start is to identify an interesting projection using a projection pursuit guided tour. <!--In a guided tour, the projection sequence is selected by optimizing an index function via hill-climbing on the projection space.--> Here the holes index is used to find a 2D projection of the flea data, which shows three separated groups. Figure \ref{fig:step0} shows the initial projection of the data. The left panel displays the projection basis ($\textbf{B}$) and can be used as a visual guide of the magnitude and direction that each variable contributes to the projection. The right panel shows the projected data, $\textbf{Y}_{[n,~2]} ~=~ \textbf{X}_{[n,~p]} \textbf{B}_{[p,~2]}$. The color and shape of points are mapped to the flea species. This plot is made using the  \code{view\_basis()} function in \CRANpkg{spinifex}, which generates a \CRANpkg{ggplot2} [@wickham_ggplot2:_2016] object. 

```{r step0, echo=F, results='hide', out.width='70%',                             fig.cap = "Initial 2D projection: representation of the basis  (left) and resulting data projection (right) of standardized flea data. The color and shape of data points are mapped to beetle species. The basis was identified using a projection pursuit guided tour, with the holes index. The contribution of the variables aede2 and tars1 approximately contrasts the other variables. The visible structure in the projection are the three clusters corresponding to the three species. Produced with the function \\code{view\\_basis()}."}
## Flea holes tour
set.seed(20190425)
f_dat  <- tourr::rescale(flea[,1:6])
f_cat  <- factor(flea$species)
f_path <- save_history(f_dat, guided_tour(holes()))
f_bas  <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2)
f_mvar <- 5
f_msp  <- create_manip_space(basis = f_bas, manip_var = f_mvar)
f_proj <- data.frame(tourr::rescale(f_dat %*% f_msp[, 1:2]))

# step0, output
# Adjust centering to make axes and data side by side
view_basis(f_bas, labels = colnames(f_dat)) +
  geom_point(data = f_proj,
             mapping = aes(x = X1 + .75, y = X2 - .5, color = f_cat),
             pch = as.integer(f_cat) + 15) +
  theme(panel.border = element_rect(colour = "black", fill = NA))
```


### Step 1) Choose manip variable

<!-- select a manip var-->
In Figure \ref{fig:step0} the contribution of the variables tars1 and aede2 mostly contrast the contribution of the other four variables. These two variables combined contribute in the direction of the projection where the purple cluster is separated from the other two clusters. The variable aede2 is selected as the manip var, the variable to be controlled in the tour. The question that will be explored, is, how important this variable is to the separation of the clusters.


### Step 2) Create the 3D manip space

<!-- Zero Vect, manip sp -->
Initialize the coordinate basis vector as a zero vector $\textbf{e}$ of length $p$, and set the $k$-th element to 1. In the example data, aede2 is the fifth variable in the data, so $k=5$, set $e_5=1$. Use a Gram-Schmidt process to orthonormalize the coordinate basis vector on the original 2D projection to describe a 3D manip space, $\textbf{M}$.

\begin{align*}
  e_k &\leftarrow 1 \\ 
  \textbf{e}^*   &\leftarrow \textbf{e} - \langle \textbf{e}, \textbf{B}_1 \rangle \textbf{B}_1 - \langle \textbf{e}, \textbf{B}_2 \rangle \textbf{B}_2 \\ 
  \textbf{M}_{[p,~3]} &= (\textbf{B}_1,\textbf{B}_2,\textbf{e}^*)
\end{align*}

<!-- What the manip space provides -->
The manip space provides a 3D projection from $p$-dimensional space, where the coefficient of the manip var can range completely between [0, 1]. 3D rotation can be used to rotate the manip variable completely into or completely out of a 2D projection. Figure \ref{fig:step2} illustrates this 3D manip space with the manip var highlighted. This representation is produced by calling the \code{view\_manip\_space()} function. This diagram is purely used to help explain the algorithm.

```{r step2, echo=F, out.width='70%',                                           fig.cap = "Illustration of a 3D manip space, constructed to change the contribution of the variable aede2 in the example data. The red circle indicates a unit sphere. The 2D projection is represented by the blue circle, with the projection coefficients represented by grey lines and text. The manip var axis, in red, has length 1 touching the sphere, extends the projection to a third dimension. The shadow of this axis (blue) is its contribution in the original 2D projection. Illustrated with the \\code{view\\_manip\\_space()} function."}
view_manip_space2(basis = f_bas, manip_var = f_mvar, labels = colnames(f_dat)) +
    theme(panel.border = element_rect(colour = "black", fill = NA))
```


### Step 3) Defining a 3D rotation

<!-- illustration of axis manip -->
The basis vector corresponding to the manip var (red line in Figure \ref{fig:step2}), can be operated like a lever. This is the process of the manual control, that rotates the manip variable into and out of the 2D projection (Figure \ref{fig:step3}). As the variable contribution is controlled, the manip space rotates, and the projection onto the horizontal projection plane correspondingly changes. This is a manual tour. Generating a sequence of values for the rotation angles produces a path for the rotation of the manip space. <!--This defines the (orthonormally-constrained) rotation on the basis coefficients.-->

<!-- describe manip var path -->
For a radial tour, fix $\theta$, the angle describing rotation within the projection plane, and compute a sequence for $\phi$, defining movement out of the plane. This will change the initial value, $\phi_1$, the angle between $\textbf{e}$ and its shadow in $\textbf{B}$, to a maximum of $0$ (manip var fully in projection), then to a minimum of $\pi/2$ (manip var out of projection), before returning to $\phi_1$. 

<!-- define the rotation matrix -->
Rotations in 3D can be defined by the axes they pivot on. Rotation within the projection, $\theta$, is rotation around the $Z$ axis. Out-of-projection rotation, $\phi$, is the rotation around an axis on the $XY$ plane, $\textbf{U}$, orthogonal to $\textbf{e}$. Given these axes, the rotation matrix, $\textbf{R}$ can be written as follows, using Rodrigues' rotation formula (originally published in @rodrigues_lois_1840):

  \begin{align*}
    \textbf{R}_{[3,~3]} 
    &= \textbf{I}_3 + s_\phi\*\textbf{U} + (1-c_\phi)\*\textbf{U}^2 \\
        &=
    \begin{bmatrix}
      1&0&0 \\ 
      0&1&0 \\ 
      0&0&1 \\
    \end{bmatrix} +
    \begin{bmatrix}
      0 & 0 & c_\theta s_\phi \\
      0 & 0 & s_\theta s_\phi \\
      -c_\theta s_\phi & -s_\theta s_\phi & 0 \\
    \end{bmatrix} +
    \begin{bmatrix}
      -c_\theta (1-c_\phi) & s^2_\theta (1-c_\phi) & 0 \\
      -c_\theta s_\theta (1-c_\phi) & -s^2_\theta (1-c_\phi) & 0 \\
      0 & 0 & c_\phi-1 \\
    \end{bmatrix} \\
    &= 
    \begin{bmatrix}
      c_\theta^2 c_\phi + s_\theta^2 &
      -c_\theta s_\theta (1 - c_\phi) &
      -c_\theta s_\phi \\
      -c_\theta s_\theta (1 - c_\phi) &
      s_\theta^2 c_\phi + c_\theta^2 &
      -s_\theta s_\phi \\
      c_\theta s_\phi &
      s_\theta s_\phi &
      c_\phi
    \end{bmatrix} \\
\end{align*}

\noindent where

\begin{align*}
  \textbf{U} &= (u_x, u_y, u_z) =
  (s_\theta, -c_\theta, 0) \\ 
  &=
  \begin{bmatrix}
  0 & -u_z & u_y  \\
  u_z & 0 & -u_x \\
  -u_y & u_x & 0 \\
  \end{bmatrix} =
  \begin{bmatrix}
    0 & 0 & -c_\theta \\
    0 & 0 & -s_\theta \\
    c_\theta & s_\theta & 0 \\
  \end{bmatrix} \\
  \end{align*}
  
<!-- The term $(1-c_\phi)$ is used by convention, but $2sin^2(\phi/2)$ is more computationally robust. -->

<!-- rotate manip space -->
<!--Defining the axis of rotation for $\phi$ and the application of Rodrigues' rotation formula results in the rotation matrix, the rotation group SO(3). Continue with the rotation of the manip space, post-multiply the space by the above rotation matrix producing **RM**, the rotated manip space. This is basis values, the linear combination of variables, for one frame of the animation, repeat this process over a sequence of values for $\phi$ to produce an animation.
-->

<!-- **For each value of ** $\phi_i$ **:** -->

<!-- \begin{align*} -->
<!--   \textbf{RM}_{[p,~3,~i]} &= \textbf{M}_{[p,~3]} ~*~ \textbf{R}_{[3,~3,~i]}  -->
<!-- \end{align*} -->

### Step 4) Creating an animation of the radial rotation

<!--  phi transform and animation -->
The steps outlined above can be used to create any arbitrary rotation in the manip space. To use these for sensitivity analysis, the radial rotation is built into an animation where the manip var is rotated fully into the projection, completely out, and then back to the initial value. This involves allowing $\phi$ to vary between 0 and $\pi/2$, call the steps $\phi_i$. 

<!--Apply the transformation $\phi_i \leftarrow \phi_i-\phi_1$ such that $\phi$ is relative to the projection plane. When $\phi$ is 0, $|\textbf{B}_k| = 1$, and when $\phi$ is $\pi/2$, the manip var has no contribution to the projection.--> 


```{r step3, echo=F, warning=F, fig.height=2, fig.width=8, out.width='100%',  fig.cap = "Snapshots of a radial manual tour manipulating aede2: (1) original projection, (2) full contribution, (3) zero contribution, (4) back to original. "}
f_angle <- .26
f_mtour <- manual_tour(f_bas, manip_var = f_mvar, angle = f_angle)
if(dim(f_mtour)[3] != 15) message(
  paste0("!!!!! step3 n_slides != 15 !!!!! Please knit again. n_slides = ", dim(f_mtour)[3]))
p1 <- view_basis2(f_mtour[,,1],  colnames(f_dat), manip_var = f_mvar) + ggtitle("1 phi=0.78")
p2 <- view_basis2(f_mtour[,,6],  colnames(f_dat), manip_var = f_mvar) + ggtitle("2  phi=0")
p3 <- view_basis2(f_mtour[,,12], colnames(f_dat), manip_var = f_mvar) + ggtitle("3 phi=1.57")
p4 <- view_basis2(f_mtour[,,15], colnames(f_dat), manip_var = f_mvar) + ggtitle("4 phi=0.78")
grid.arrange(p1, p2, p3, p4, ncol=4)
```

<!--### Sequence of $\phi_i$-->

1. Set initial value of $\phi_1$ and $\theta$: $\phi_1 = \cos^{-1}{\sqrt{B_{k1}^2+B_{k2}^2}}$, $\theta=\tan^{-1}\frac{B_{k2}}{B_{k1}}$. $\phi_1$ is the angle between $\textbf{e}$ and its shadow in $\textbf{B}$. Check that  $\phi_1$ is between 0 and $\pi/2$, and if not, transform it into this range, by subtracting or adding $\pi$. (XXX Nick needs to check this math, and the ways to check and fix if angle produced by the calculation given fall in the right range.)
2. Set an angle increment ($\Delta_\phi$) that sets the step size for the animation, to rotate the manip var into and out of the projection. (Note: Using angle increment, rather than a number of steps, to control the movement, is consistent with the tour algorithm as implemented in the \pkg{tourr}).
3. Step towards $0$, where the manip var is completely in the projection.
4. Step towards $\pi/2$, where the manip variable has no contribution.
5. Step back to $\phi_1$.

In each of the steps 3-5, a small step may be added to ensure that the endpoints of $\phi$ (0, $\pi/2$) are reached. 

### Step 4) Projecting the data {#sec:display}

<!-- the reminder of basis operation and now apply data -->
The operation of a manual tour is defined on the projection bases. Only when the data plot needs to be made is the data projected into the relevant basis. 

\begin{align*}
  \textbf{Y}_{[n,~3]} &= \textbf{X}_{[n,~p]} \textbf{M}_{[p,~3]} \textbf{R}^{(i)}_{[3,3]}
\end{align*}

<!-- plot 2 var in seq for animation -->
\noindent where $\textbf{R}^{(i)}_{[3,3]}$ is the incremental rotation matrix, using $\phi_i$. To make the data plot, use the first two columns of \textbf{Y}. Show the projected data for each frame in sequence to form an animation. <!--The remaining manip space variable can be linked to point aesthetic (such as size or color) to produce depth cues used in conjunction with the $XY$ scatterplot.-->

<!-- Animation on flea data -->
Figure \ref{fig:step4} illustrates a manual tour sequence having 15 steps. The projection axes are displayed on the top half, which corresponds to the projected data in the bottom half. When aede2 is removed from the projection, the purple cluster overlaps with the green cluster. This suggests that aede2 is important for distinguishing this species. 

Tours are typically viewed as an animation. The animation of this tour can be viewed online at https://nspyrison.netlify.com/thesis/flea_manualtour_mvar5/. The page may take a moment to load. Animations can be produced using the function \code{play\_manual\_tour()}.

```{r step4, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                                                fig.cap = "Radial manual tour manipulating aede2 of standardized flea data. The axis for aede2 increases in contribution to the projection, from its initial value to 1, decreasing to 0 and then returning to the initial value. This affects the separatiion between the purple and green clusters. This shows that aede2 is important for distinguishing the purple species, because the separation disappears when aede2 is not contributing to the projection. An animation can be viewed at https://nspyrison.netlify.com/thesis/flea\\_manualtour\\_mvar5/."}
#play_manual_tour(f_dat, f_bas, f_mvar, col = f_cat, angle = f_angle)
array2static(.m_tour = f_mtour, .data = f_dat, .m_var = f_mvar, .cat = f_cat)
```

<!--
### Checks that need to be made

The initial value of $\phi$ is determined by the angle between $\textbf{e}$ and its shadow in $\textbf{B}$. 

relative to its initial value. The transformation $\phi_i$ - $\phi_1$ is useful to think about $\phi$ relative to the basis plane. Additionally, the value of $\phi$ may be out of phase by a factor of $\pi$. If the rotation does not behave as expected these are the first places to check.
-->


# Package structure and functionality {#sec:usage}

This section describes the functions available in the package, and how to use them.

## Installation

The \CRANpkg{spinifex} is available from CRAN, and can be installed by: 
```{r installCODEEXAMPLE, eval=F, echo=T}
install.package("spinifex")
library("spinifex")
```

\noindent Also see the vignette for examples of usage: 

```
vignette("spinifex_vignette")
```

\noindent The development version can be installed from github:

```
remotes::install_github("nspyrison/spinifex") 
```

## Functions 
<!-- in terms of work flow. -->

Table \ref{tab:functionsTable} lists the primary functions and their purpose. These are grouped into four types: construction for building a tour path, render to make the plot objects, animation for running the animation, and specialty for providing illustrations used in the algorithm description.

<!--
The primary functions that will aid users in performing their own manual tours are broken into the following groupings: tour preparation, tour animation, and utility. In the following section describes and demonstrates the usage of the above functions following the order in the algorithm. The utility functions are called by the tour animation functions, passed to the argument \code{render\_type}. Usage is demonstrated below and in the example documentation.-->

```{r functionsTable, echo=F}
library(kableExtra)

funcs <- rbind(
  c("construction", "create_manip_space", "forms the 3D space of rotation"),
  c("construction", "rotate_manip_space", "performs 3D rotation"),
  c("construction", "manual_tour", "generates sequence of 2D frames"),
  c("", "", ""),
  c("render", "render_", "constructs the ggplot object to feed to animation"),
  c("render", "render_plotly", "converts the ggplot object to a plotly animation"),
  c("render", "render_gganimate", "converts the ggplot object to a gganimate  animation"),
  c("render", "array2df", "turns a tour path array into long form, for plotting"),
  c("", "", ""),
  c("animation", "play_tour_path", "animates given tour path"),
  c("animation", "play_manual_tour", "animates the manual tour algorithm"),
  c("", "", ""),
  # c("utility", "col_of", "maps a variable to the point color"),
  # c("utility", "pch_of", "maps a variable to the point character (shape)"),
  c("specialty", "view_basis", "displays the reference frame of a given basis"),
  c("specialty", "view_manip_space", "illustrative display of any manip space")
)
colnames(funcs) <- c("Type", "Function", "Description")
  
kable(funcs, "latex", caption = "Summary of available functions.", booktabs = T, linesep="") 
```


## Usage

Using the `flea` data from the \CRANpkg{tourr} package, we will illustrate generating a manual tour to explore the sensitivity of the cluster structure is to the variable `aede2`. 

<!--
We'll start by initializing values including a standardized data set (numeric columns only), a starting basis, a categorical variable for point aesthetics (optional), and a manip var. To get bearings on the projection, start by observing the reference axes of the basis with \code{view\_basis()} producing Figure \ref{fig:step0}.-->

<!-- setup -->
```{r step0CODEEXAMPLE, eval=F, echo=T}
library(spinifex)
f_data  <- tourr::rescale(flea[, 1:6])                    ## standardize data
f_path  <- save_history(f_data, guided_tour(holes()))     ## guided tour using holes index
f_basis <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2) ## optimal projection
f_cat   <- factor(flea$species)                           ## categorical var
f_mvar  <- 5                                              ## set manip var
angle_speed <- .26
play_manual_tour(data = f_data,                           ## Generates animation
                 basis = f_basis,                         ## using plotly
                 manip_var = f_mvar, 
                 angle = angle_speed,
                 col = f_cat,
                 pch = f_cat)
```

<!--After becoming familiar with this space, select a manip var, the variable to change the contributions of. Use \code{view\_manip\_space()} to view the new space with a dimension orthogonal to the projection plane where the manip var has a full contribution. This illustrates how the manip var is manipulated with the addition of the manip space as shown in Figure \ref{fig:step2}.


Now we are ready to perform a manual tour on the selected variable. Use \code{play\_manual\_tour()} to perform the algorithm as discussed above, in section \ref{sec:algorithm}. This is the animated equivalent of Figure \ref{fig:step3}. -->

The `play_manual_tour` function is a composite function for user convenience that does these operations:

```{r eval=FALSE, echo=TRUE}
manual_tour()
array2df()
render_plotly()
```

\noindent This will generate an html animation using plotly. Switching the renderer to `gganimate` is an option, which will also create an html animation or an animated gif. Each of these formats allows for the animation to be made available on a web site, or directly visible in an html formatted document.

<!--
This concludes the content of the algorithm section, however, lets cover animating paths generated in \pkg{tourr}. Animate the previously generated guided tour path via \code{play\_tour\_path()}. Utility functions can also be passed as arguments into either of the tour animation function to change the resulting graphics object, set \code{render\_type = render\_gganimate} to view the animation as a GIF.

```{r guidedTourCODEEXAMPLE, eval=F, echo=T}
play_tour_path(tour_path = f_path,
               data = f_data,
               render_type = render_gganimate, 
               angle = angle_speed
)
```
-->

### Making illustrations

The function `view_basis` can be used to show a projection, just the basis, or with the data overlaid. For example, the plots in Figures \ref{fig:step0} and \ref{fig:step3} were made with code similar to this:

```{r eval=FALSE}
view_basis(basis = f_basis, 
           data = f_data,
           labels = colnames(f_data))
```

\noindent An illustration of the manip space (as shown in Figure \ref{fig:step2}) is made with the `view_manip_space` function, as follows: 

<!-- step 2 disp code. -->
```{r step2CODEEXAMPLE, eval=F, echo=T}

view_manip_space(basis = f_basis, 
                 manip_var = f_mvar, 
                 labels = colnames(f_data))
```

<!--
## Rendering and sharing

The \pkg{tourr} package utilizes \pkg{base} graphics for the display of tours. \pkg{spinifex} allows tours to be rendered in \pkg{plotly} as an HTML5 object or \pkg{gganimate} as GIF or MP4 files. Sharing of animations is not trivial, especially static formats like print and PDF. Even with dynamic display capturing the correct resolution and aspect ratio can be challenging, while many formats quickly bloat file sizes limiting sharing options. Keep in mind hosting options and exporting functions offered in \pkg{plotly}, \pkg{gganimate} and \pkg{tourr}.


## Storage

Storing each data point for every frame of the animation is redundant. Just as operations are performed on the bases, so too should tour paths be stored as bases and a single instance of the data. Consider a radial manual tour, we can store the salient features in 3 bases, where $\phi$ is at its starting, minimum, and maximum values. The frames in between can be interpolated by supplying angular speed. With the use of the \code{tourr::save\_history()} function, the target bases can be saved. From there geodesic interpolation can be used to populate the intermittent frames. This type of interpolation should not be used on manual tours, which have already been initialized into a 3D manip space where direct linear interpolation is appropriate.
-->

# Application {#sec:application}

<!-- Introduction of data and original paper -->
@wang_mapping_2018 introduce a new tool, PDFSense, to visualize the sensitivity of hadronic experiments to nucleon structure. The parameter-space of these experiments lies in 56 dimensions, $\delta \in \mathbb{R}^{56}$, and are visualized as 3D subspaces of the 10 first principal components in linear (PCA) and non-linear (t-SNE) embeddings. 

<!-- grand tours on the same data -->
@cook_dynamical_2018 illustrates how to learn more about the structures using a grand tour. Tours are able to better resolve the shape of clusters, intra-cluster detail, and better outlier detection than PDFSense & TFEP (TensorFlow embedded projections) or traditional static embeddings. This example builds from here, illustrating how the manual tour can be used to examine the sensitivity of structure in a projection to different parameters. The specific 2D projections passed to the manual tour were provided from @cook_dynamical_2018. 

<!-- Data structure -->
The data has a hierarchical structure with top-level clusters; DIS, VBP, and jet. Each cluster is a particular class of experiments, each with many experimental datasets which, in turn, have many observations. In consideration of data density, we conduct manual tours on subsets of the DIS and jet clusters. This explores the sensitivity of the structure to each of the variables in turn and we present the subjectively best and worst variable to manipulate for identifying dimensionality of the clusters and describing the span of the clusters.


## Jet cluster

<!-- jet cluster, explain dimensionality -->
The jet cluster resides in a smaller dimensionality than the full set of experiments with four principal components explaining 95% of the variation in the cluster [@cook_dynamical_2018]. The data within this 4D embedding is further subsetted, to ATLAS7old and ATLAS7new, in order to focus on two groups, with a reasonable number of observations, that occupy different parts of the subspace. Radial manual tours controlling contributions from PC4 and PC3 are shown in Figures \ref{fig:JetClusterGood} and  \ref{fig:JetClusterBad}, respectively. The difference in shape can be interpreted as the experiments probing different phase-spaces. Back-transforming the principal components to the original variables can be done for more detailed interpretation.
<!--These variables are selected to contrast the information conveyed by different manip variables. Links to dynamic HTML5 animations controlling each of the four variables are also provided.--> 

<!-- discussion of findings and which is more insightful -->
When PC4 is removed from the projection (Figure \ref{fig:JetClusterGood}), the difference between the two groups is removed, indicating that it is important for distinguishing experiments. However, removing PC3 from the projection (Figure \ref{fig:JetClusterBad}), has no effect on the structure, indicating it is not important for distinguishing experiments. 
<!--, there is a clear difference in the parameter space spanned by the experiment types ATLAS7new and ATLAS7old. Specifically, the variation of ATLAS7new (green) becomes more singular. The experiments are probing different parameter space and PC4 is important to demonstrate this. Yet, when PC3 is manipulated there is no clear indication that the different experiments probe different parameter space. Performing a radial manual tour on PC4 is more insightful than for PC3.-->
Animations for the remaining PCs can be viewed at the following links: [PC1](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc1/), [PC2](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc2/), [PC3](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc3/), and [PC4](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc4/). It can be seen that only PC4 is important for viewing the difference in these two experiments.


```{r JetClusterGood, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                     fig.cap="Snapshots of a radial manual tour of PC4 focusing on the jet cluster, with color indicating experiment type: ATLAS7new (green) and ATLAS7old (orange).  When PC4 is removed from the projection (frame 10) there is little difference between the groups, suggesting that PC4 is important for distinguishing the experiments.  The animation can be viewed at https://nspyrison.netlify.com/thesis/jetcluster\\_manualtour\\_pc4/."}
# Jet cluster, Fig 7 of cook_dynamical_2018, subset to ATLAS7old and ATLAS7new
load("./data/JetCluster_sub.rda")
load("./data/JetCluster_basis.rda")

jet_bas   <- JetCluster_basis
jet_dat   <- tourr::rescale(JetCluster_sub[, 1:4])
jet_cat   <- factor(JetCluster_sub$exp)
jet_mvar  <- 4
jet_ang   <- .26
jet_mtour <- manual_tour(basis = jet_bas, manip_var = jet_mvar, angle = jet_ang)
#dim(jet_mtour)

array2static(.m_tour = jet_mtour, .data = jet_dat,
             .m_var = jet_mvar, .cat = jet_cat)
# play_manual_tour(data = jet_dat, basis = jet_bas, manip_var = jet_mvar,
#                  angle = jet_ang, axes = "bottomleft", col = jet_cat)

##M_VAR, RESULT
# 1, good
# 2, poor
# 3, *worst
# 4, *best
```


```{r JetClusterBad, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                       fig.cap = "Snapshots of a radial manual tour of PC3 focusing on the jet cluster, with color indicating experiment type: ATLAS7new (green) and ATLAS7old (orange).  When the contribution of PC3 is changed there is little change to the structure of the two groups, suggesting that PC3 is not important for distinguishing the experiments. The animation can be viewed at https://nspyrison.netlify.com/thesis/jetcluster\\_manualtour\\_pc3/."}
# Jet cluster, Fig 7 of cook_dynalical_2018, subset to ATLAS7old and ATLAS7new
jet_mvar  <- 3
jet_mtour <- manual_tour(basis = jet_bas, manip_var = jet_mvar, angle = jet_ang)

array2static(.m_tour = jet_mtour, .data = jet_dat,
             .m_var = jet_mvar, .cat = jet_cat)
```


## DIS cluster

<!-- introduce DIS cluster -->
Following @cook_dynamical_2018, to explore the DIS cluster, PCA is recomputed and the first six principal components, explaining 48% of the variation is used. The contributions of PC6 and PC2 are explored in Figures \ref{fig:DISclusterGood} and  \ref{fig:DISclusterBad}, respectively. Three experiments are examined: DIS HERA1+2 (green), dimuon SIDIS (purple), and charm SIDIS (orange).

<!-- comparison of the DIS cluster -->
Both PC2 and PC6 contribute to the projection similarly. When PC6 is rotated into the projection, variation in the DIS HERA1+2 is greatly reduced. When PC2 is removed from the projection, dimuon SIDIS becomes more clearly distinct. Even though both variables contribute similarly to the original projection, their contributions have quite different effects on the structure of each cluster, and the distinction between clusters. Animations of all of the principal components can be viewed from the links: [PC1](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc1/), [PC2](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc2/), [PC3](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc3/), [PC4](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc4/), [PC5](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc5/), and [PC6](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc6/).


```{r DISclusterGood, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                            fig.cap = "Snapshots of a radial manual tour exploring the contribution of PC6 for the DIS cluster, with color indicating experiment type: DIS HERA1+2 (green), dimuon SIDIS (purple), and charm SIDIS (orange). DIS HERA1+2 is distributed in a cross-shaped plane, charm SIDIS occupies the center of this cross, and dimuon SIDIS is a linear cluster crossing DIS HERA1+2. As PC6's contribution is increased, DIS HERA1+2 becomes almost singular in one direction (frame 5), indicating that this experiment has very little variability in the direction of PC6.  The animation can be viewed at https://nspyrison.netlify.com/thesis/discluster\\_manualtour\\_pc6/."}

##DIS cluster, fig 8 of cook_dynamical_2018
load("./data/grDIScenter.rda")
load("./data/DIScluster_centered_basis.rda")
DIS_bas   <- DIScluster_centered_basis
DIS_dat   <- tourr::rescale(grDIScenter[, 1:6])
DIS_cat   <- factor(grDIScenter$disID)
DIS_mvar  <- 6
DIS_ang   <- .27
DIS_mtour <- manual_tour(basis = DIS_bas, manip_var = DIS_mvar, angle = DIS_ang)

array2static(.m_tour = DIS_mtour, .data = DIS_dat,
             .m_var = DIS_mvar, .cat = DIS_cat)
# play_manual_tour(data = DIS_dat, basis = DIS_bas, manip_var = DIS_mvar,
#                  angle = DIS_ang, axes="bottomleft", col = DIS_cat)

##M_VAR, RESULT
# 1, purple jet
# 2, *poor
# 3, black
# 4, plane
# 5, black and plane
# 6, best*purple and plane
```


```{r DISclusterBad, echo=F, warning=F, fig.height=7.0, fig.width=5.83, out.height='7in', out.width='5.83in',                                            fig.cap = "Snapshots of a radial manual tour exploring the contribution of PC2 for the DIS cluster, with color indicating experiment type: DIS HERA1+2 (green), dimuon SIDIS (purple), and charm SIDIS (orange). As PC2's contribution is decreased, dimuon SIDIS becomes more distinguishable from the other two clusters (frames 10-14), indicating that in its absence PC2 is important.  The animation can be viewed at https://nspyrison.netlify.com/thesis/discluster\\_manualtour\\_pc2/."}
##DIS cluster, fig 8 of cook_dynamical_2018
DIS_mvar  <- 2
DIS_mtour <- manual_tour(basis = DIS_bas, manip_var = DIS_mvar, angle = DIS_ang)

array2static(.m_tour = DIS_mtour, .data = DIS_dat,
             .m_var = DIS_mvar, .cat = DIS_cat)
```


# Discussion {#sec:discussion}

<!-- summary of spinifex  -->
Dynamic linear projections of numeric multivariate data, tours, play an important role in data visualization; they extend the dimensionality of visuals to peek into high-dimensional data and parameter spaces. This research has taken the manual tour algorithm, specifically the radial rotation, used in GGobi [@swayne_ggobi:_2003] to interactively rotate a variable into or out of a 2D projection, and modified it to create an animation that performs the same task. It is most useful for examining the importance of variables, and how the structure in the projection is sensitive or not to specific variables. This functionality available in package \CRANpkg{spinifex}. The work complements the methods available in the \CRANpkg{tourr} package.

<!-- summary of application  -->
This work was motivated by problems in physics, and thus the usage was illustrated on data comparing experiments of hadronic collisions, to explore the sensitivity of cluster structure to different principal components. These tools can be applied quite broadly, to many multivariate data analysis problems.  <!--The importance of selecting the correct manip var, as demonstrated by comparing tours of varying amounts of structural information. Manual tours, by controlling the contribution of the manip var on the projection, enable analysts to explore the sensitivity that variable has on the structure of the projection. This information can be used by domain experts to identify which variables are probing which parameter spaces and how sensitive structural features are to different variables. This insight can be indispensable for variable inclusion/exclusion, and in higher-level decisions, such as meta-analysis, to suggest directions of future research.--> 

<!-- Constraints -->
The manual tour is constrained in the sense that the effect of one variable is dependent on the contributions of other variables in the manip space. However, this can be useful to simplify a projection, to remove variables without affecting the visible structure. Defining a manual rotation in high dimensions is possible using Givens rotations and Householder reflections as outlined in @buja_computational_2005. This would provide more flexible manual rotation, but more difficult for a user because they have the choice (too much choice) of which directions to move.  <!--Currently, Gram-Schmidt is the only form of frame interpolation used. In a Givens rotation, the $x$ and $y$ components (for example $\theta~= 0,~pi/2$) of the in-plane rotation are calculated separately and would be applied sequentially to produce the radial rotation. Householder reflections define reflection axes to project points on to the axes to generate rotations.-->


<!-- 3D and function vis -->
Another future research topic could be to extend the algorithm for use on 3D projections. With the current popularity and availability of 3D virtual displays, this may benefit the detection and understanding of the higher dimensional structure, or enable the examination of functions.

<!--The addition of another dimension theoretically allows for improved perception. In some frameworks, such as the game engine **unity**, this would allow for the exploration in immersive virtual reality or mixed reality, which may further allow for a better perception of structure and aid in higher-dimensional function visualization. Functions with many parameters suffer from the same dimensionality problem as data while their possible values lie on a surface of values rather than discrete points. Occulation, or the closer surface blocking further surfaces, will likely be an issue that may be alleviated by the use of wire mesh, changing opacity, or looking at sections of the projections known as prosections [@furnas_prosection_1994].-->

<!-- geometric and graphics display 
The \pkg{tourr} package provides many other geometric displays with the \code{tourr::display\_*()} family. These geometric options could be integrated into the \pkg{ggplot2} framework for display on \pkg{plotly} and \pkg{gganimate}. Additionally, the \CRANpkg{animation} package @xie_animation:_2018 could be implemented for another graphics framework. However, \pkg{animation} builds from \pkg{base} graphics while \pkg{spinifex} utilizes \pkg{ggplot2} graphics, a significant paradigm shift, which may have  a low return on investment.-->

<!-- interpolation 
The Givens rotations and Householder reflections as outlined in @buja_computational_2005 could also be added. Currently, Gram-Schmidt is the only form of frame interpolation used. In a Givens rotation, the $x$ and $y$ components (for example $\theta~= 0,~pi/2$) of the in-plane rotation are calculated separately and would be applied sequentially to produce the radial rotation. Householder reflections define reflection axes to project points on to the axes to generate rotations.-->

<!-- dynamic interaction/gui -->
Having a graphical user interface would be useful for making it easier and more accessible to a general audience. This is possible to implement using \CRANpkg{shiny} [@chang_shiny:_2018]. The primary purposes of the interface would be to allow the user to interactively change the manip variable easily, and the interpolation step for more or less detailed views.

<!--Having script-only interaction with tours causes a significant barrier to entry. To a lesser extent, \pkg{plotly} offers some static interactions with the contained object, such as tooltips, brushing, and linking without communicating back to the R console. The development of a dynamic graphical user interface, perhaps with the use of a \CRANpkg{shiny} [@chang_shiny:_2018] application, would mitigate the barrier to entry, allow for more rapid analysis, and offer an approachable demo tool. The user could easily switch between variables to control, adjust the interpolation step angle, or flag/save specific frame basis sets.--> 

# Acknowledgments

This article was created in R [@r_core_team_r:_2018], using \CRANpkg{knitr} [@stodden_knitr:_2014] and \CRANpkg{rmarkdown} [@xie_r_2018], with code generating the examples inline. The source files for this article be found at [github.com/nspyrison/spinifex_paper/](https://github.com/nspyrison/spinifex_paper/). The source code for the \pkg{spinifex} package can be found at [github.com/nspyrison/spinifex/](https://github.com/nspyrison/spinifex/).


# Bibliography

