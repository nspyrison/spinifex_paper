---
title: > 
  spinifex: A Package for Manual Control of Dynamic Linear Projections of Multivariate Data
author:
  - name: Nicholas Spyrison
    affiliation: Monash University 
    address:
    - Faculty of Information Technology
    email:  Nicholas.Spyrison@monash.edu
  - name: Dianne Cook
    affiliation: Monash University 
    address:
    - Department of Econometrics and Business Statistics
    email:  DiCook@monash.edu
abstract: >
  The set of dynamic linear projections of multivariate data collectively known as **tours** provides an important tool for extending the dimensionality of visuals. The R package **tourr** offers a variety of path generators and geometric displays for conducting tours. This paper discusses an extension package, **spinifex**, that adds support for the path generation of manual tours and extends the display of tours to use with the animation packages, **plotly** and **gganimate**. Manual tours are used to explore the sensitivity of structure as the contributions of a manipulation variable are changed.
  
  A recent paper [@wang_mapping_2018] visualized the sensitivity of the hadronic experiments to nucleon structure. Sensitivity was characterized in non-linear 3D embeddings of the first 10 principal components. This research applies manual tours to this data showing that manual tours resolve information about the structure of cluster distribution by bringing to light information that is orthogonal to static viewing planes.
keywords: manual tour, guided tour, grand tour, projection pursuit, high dimensional data, multivariate data, data visualization, statistical graphics, data science
preamble: >
  % preamble packages
link-citations: true
fig_caption: yes
toc: false
bibliography: spinifex_paper.bib
output: rticles::rjournal_article
  #bookdown::pdf_book:
   # base_format: rticles::rjournal_article #see sandbox for hard code solution.
---
\bibliography{spinifex_paper}
<!-- note that Di/Ursula have different setup and options and use static images.  -->
```{r setup_paper, include=FALSE}
knitr::opts_chunk$set(
  fig.align = "center", echo = TRUE, collapse = TRUE,
  message = FALSE, warning = FALSE, error = FALSE,
  cache = F, cache.lazy = FALSE
)
library(spinifex)
library(ggplot2)
```

```{r localFunction, include=FALSE}
## FUNCTION FOR STATIC OUTPPUT, consider going to scalable facets.
array2static <- function(.m_tour, .data, .m_var, .cat, .mag =2.2)
{
  slides       <- array2df(array = .m_tour, data = .data)
  basis_slides <- slides$basis_slides
  data_slides  <- slides$data_slides
  n_slides     <- max(basis_slides$slide)
  if (n_slides != 15) 
    stop(paste0("stop: n_slides !=15 !!!!! n_slides = ", n_slides))
  
  # Initialize
  ## manip var asethetics
  p             <- nrow(basis_slides) / n_slides
  col_v         <- rep("grey80", p)
  col_v[.m_var] <- "blue"
  col_v         <- rep(col_v, n_slides)
  siz_v         <- rep(0.3, p)
  siz_v[.m_var] <- 1
  siz_v         <- rep(siz_v, n_slides)
  cat           <- rep(as.factor(.cat), n_slides)

  ## circle
  angle <- seq(0, 2 * pi, length = 180)
  circ  <- data.frame(c_x = cos(angle), c_y = sin(angle))
  circ[nrow(circ)+1, ] <- NA
  ## data asethetics
  data_slides <- data.frame(data_slides, cat = rep(.cat, n_slides))
  
  grid_b <- grid_t <-
    data.frame(slide = 1:n_slides, 
               x = .mag*rep(1:5, 3), y = .mag*rep(3:1, each = 5))
  grid_t$y <- grid_t$y + max(grid_t$y)
  # OUTER JOIN
  basis_grid <- merge(x = basis_slides, y = grid_t, by = "slide", all = TRUE)
  # CROSS JOIN
  circ_grid  <- merge(x = circ, y = grid_t, by = NULL)
  # OUTER JOIN
  data_grid  <- merge(x = data_slides, y = grid_b, by = "slide", all = TRUE)
  
  # BASIS
  gg1 <-
    ggplot(data = basis_grid) +
    # AXES LINE SEGMETNS
    geom_segment(aes(x = V1 + x, y = V2 + y, xend = x, yend = y),
                 color = col_v, size = siz_v) +
    # AXES TEXT LABELS
    geom_text(aes(x = V1 + x, y = V2 + y, label = lab_abbr),
              color = col_v, vjust = "outward", hjust = "outward") +
    # AXES FRAME NUM
    geom_text(aes(x = x - .7, y = y + 1.1, 
                  label = paste0("frame: ",slide)), color = "grey50") +
    # AXES CIRCLE PATH
    suppressWarnings( # Suppress for "Removed 1 rows containing missing values."
      geom_path(data = circ_grid, color = "grey80",
                mapping = aes(x = x+c_x, y = y+c_y))
    )
  
  # PROJECTION
  gg2 <- gg1 +
    # PROJ DATA POINTS
    geom_point(data = data_grid, size = .7,
               mapping = aes(x = V1 + x, y = V2 + y, color = cat),
               shape = as.integer(cat) + 15) +
    # PROJ DATA FRAME NUM
    geom_text(data = data_grid, color = "grey50",
              mapping = aes(x = x - .7, y = y + 1.1, 
                            label = paste0("frame: ",slide))) +
    theme_void() +
    scale_color_brewer(palette = "Dark2") + 
    # coord_fixed() +
    theme(legend.position="none",
          panel.border = element_rect(colour = "black", fill = NA))
  
  gg2
}
```


# Introduction

<!-- Tours -->
A tour is a multivariate data analysis technique in which a sequence of linear (orthogonal) projections are viewed as an animation while the orientation of the projection basis is rotated across time. Each frame of the sequence corresponds to a small change in the projection for a smooth transition that preserves continuity. Tours are a crucial tool extending the dimensionality of visualization which is increasingly important as datasets and models exist in increasing cardinality. The package \CRANpkg{tourr} [@wickham_tourr_2011] builds a platform for generating tour paths and applying to a wide number of display geometrics in **base** graphics.

<!-- Manual tour -->
While there are numerous methods that generate tour paths, this research focuses on the manual tour. The manual tour was described in @cook_manual_1997 and allows a user to control the projection coefficients of a selected variable in a 2D projection. The manipulation of these coefficients allows the analyst to explore how sensitive the projection structure is to these manipulations. As manual tours operate on only one variable at a time, they particularly useful once a feature of interest has been identified. One way to identify "interesting" features is with the use of a guided tour [@hurley_analyzing_1990]. Guided tours select a very specific path, that which approachs a projection that optimizes an objective-function, similar to simulated annealing [@kirkpatrick_optimization_1983]. The direct optimization of a function allows guided tours to rapidly identify interesting projection features given the relatively large parameter-space. After a projection of interest is identified an analyst can then use the "finer brush" of the manual tour, by controlling the contributions of individual variables to explore the sensitivity they have to the projection structure.


<!-- Contributions -->
This paper offers an implementation of manual tours with the package
\CRANpkg{spinifex}. This package also exends the graphics display of **tourr** to the animation frameworks offered by \CRANpkg{plotly} [@sievert_plotly_2018] and \CRANpkg{gganimate} [@pedersen_gganimate:_2019]. The algorithm used to perform a radial manual tour is demonstrated on a toy data set. Followed by an application and disscussion of the radial manual tour on an aggregation of high energy physics experiments in a large multivariate space.

<!-- Paper outline -->
The paper is organized as follows. Section \ref{sec:algorithm} explains the algorithm using a toy dataset. Section \ref{sec:display} discusses the display of the animation after the path has been generated. Section \ref{ref:usage} explains the though the code used in the algorithm section and discusses function structure for the rest of the package. Section \ref{sec:application} illustrates how this can be used for sensitivity analysis applied to contemporary high energy physics. The last section, \ref{sec:discussion} summarizes the work and discusses future research.


<!-- Algorithm outline -->
# Algorithm {#sec:algorithm}

The section below describes the algorithm for performing a 2D radial manual tour:

1. Provided with a 2D projection, choose a variable to explore. This is called the "manip" variable.
2. Create a 3D manipulation space, where the manip variable has the full contribution.
3. Generate a rotation sequence which increases the norm of the coefficient to 1 and zeros it.

The steps are described in more detail below with description, equations, and figures. Function names are mentioned inline, but the code is aggregated in 

## Notation

This section describes the notation used in the algorithm for a 2D radial manual tour.

<!-- remember mixing latex and rmarkdown bullets isn't trivial. -->
\begin{itemize}
  \item $\textbf{X}$, the data, an $n \times p$ numeric matrix to be embedded in two dimensions.
  \item $\textbf{B} = (B_1,~ B_2)$, any orthonormal projection basis set, $p \times 2$ matrix, describing the projection from $p$ to two dimensions
  \item $\textbf{e}$, a zero column vector of length $p$ with the $k-$th element set to one, where $k$ is the number of the variable to manipulate, the manip var.
  \item $\theta$, the angle of in-projection-plane rotation, for example, on the reference axes.
  \item $\phi$, the angle of out-of-projection-plane rotation, coming into the manipulation space.
\end{itemize}

<!-- operate on bases -->
The algorithm primarily operates on projection bases and utilizes the data only when making a display. The projection space can be viewed at any point in the process by pre-multiplying the data and plotting the first two variables.


## Toy data set

<!-- describe data. -->
The flea data, originally from @lubischew_use_1962, made available in **tourr**  is used to illustrate the algorithm. The data contains 74 observations across 6 variables, which are physical measurements of the flea beetles. Each observation belong to one of three species.

<!-- Projection basis -->
The data is defined. A basis set (ideally orienting to an interesting feature) must be provided as an initial orientation. One way to identify a projection containing interesting features is to apply a guided tour. In a guided tour, the projection sequence is selected by optimizing an index function via hill-climbing on the projection space. In this case, the holes index is selected and applied to standardized flea data. The holes index is maximized when the projected observations are furthest from the center. Figure \ref{fig:step0} shows a locally optimized projection of the data. The left panel displays the reference axes of the projection basis, a visual indication of the magnitude and direction each variable contributed to the projection. The right panel shows the data as projected through the basis set described by the reference axes (left). Data points are colored and given shape according to the species (while the guided tour was unsupervised with this information).


```{r step0, echo=F, results='hide', out.width='70%',                             fig.cap = "Basis reference axes (left) and projected data (right) of standardized flea data. Data points color and shape are mapped to beetle species. The basis was identified by a holes-index guided tour. The variables aede2 and tars1 contribute mostly orthogonal to the other variables."}
## Flea holes tour
f_dat  <- tourr::rescale(flea[,1:6])
f_cat  <- factor(flea$species)
f_path <- save_history(f_dat, guided_tour(holes()))
f_bas  <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2)
f_mvar <- 5
f_msp  <- create_manip_space(basis = f_bas, manip_var = f_mvar)
f_proj <- data.frame(tourr::rescale(f_dat %*% f_msp[, 1:2]))

# step0, output
# Adjust centering to make axes and data side by side
view_basis(f_bas, labels = colnames(f_dat)) +
  geom_point(data = f_proj,
             mapping = aes(x = X1 + .75, y = X2 - .5, color = f_cat),
             pch = as.integer(f_cat) + 15) +
  theme(panel.border = element_rect(colour = "black", fill = NA))
```

Call `view_basis()` on a basis to produce a \CRANpkg{ggplot2} [@wickham_ggplot2:_2016] graphic similar to \ref{fig:step0). Projection space is always available for display via the matrix multiplication $\textbf{X}_{[n,~p]} ~*~ \textbf{B}_{[p,~d]} ~=~ \textbf{P}_{[n,~d]}$.


## Step 1) Choose variable of interest

<!-- select a manip var-->
In figure \ref{fig:step0} the contributions of the variables tars1 and aede2 are mostly orthogonal to the contributions of the other four variables. These two variables explain the variation of the data distinguishing the purple group from the rest of the sample. Select aede2 as the manip var, the variable to be manipulated, as it has a larger contribution to the projection. The question that will be explored is how important the variable aede2 is to the separation of the clusters.


## Step 2) Create the manip space

<!-- Zero Vect, manip sp -->
Initialize a zero vector **e** of length *p*. Set the fifth element to one, as  aede2 is the fifth variable in the data, giving the manip var a full contribution in this dimension. Use the Gram-Schmidt process to orthonormalize the zero vector onto the basis yielding the 3D manipulation space, **M**.

\begin{align*}
  \textbf{e}_k &\leftarrow 1 \\ 
  \textbf{e}   &\leftarrow \textbf{e} - \langle \textbf{e}, \textbf{B}_1 \rangle \textbf{B}_1 - \langle \textbf{e}, \textbf{B}_2 \rangle \textbf{B}_2 \\ 
  \textbf{M}_{[p,~3]} &= (\textbf{B}_1,\textbf{B}_2,\textbf{e})
\end{align*}

<!-- What the manip space facilitates -->
Adding this new dimension to our projection space allows for the coefficients of the manip var to be changed via rotation about the origin. For example, the ability to lift a piece of paper, rather than being constrained to a 2D plane. Orthonormalizing rescales the new vector while the projection down to 2D remains the original basis. Place the plane horizontally, with the new dimension extending vertically, with axes projecting back onto the reference axes. Figure \ref{fig:step2} illustrates this 3D manipulation space with the manip var highlighted (height of the other variables are not depicted.) 



```{r step2, echo=F, out.width='70%',                                           fig.cap = "Manipulation space for controlling the contribution of aede2 of standardized flea data. Basis selected by a holes-index optimized guided tour lies on the horizontal projection plane, shown in blue. The manip var axis, in red, extends into the vertical manipulation space, allowing the coefficients of the manip var to be changed by rotation around the origin."}

view_manip_space(basis = f_bas, manip_var = f_mvar, labels = colnames(f_dat)) +
    theme(panel.border = element_rect(colour = "black", fill = NA))
```

The representation in figure \ref{fig:step2} can be produced by calling the function `view_manip_space()`.


## Step 3) Generate rotation

<!-- illustration of axis manip -->
Imagine holding the manip var, the red axis, one end fixed to the origin. As it is controlled the manipulation space rotates about the origin, the projection onto the horizontal projection plane correspondingly moves. This is what happens in a manual tour. Generating a sequence of values for the horizontal and vertical, angles produces a path for the rotation of the manipulation space. This defines the (orthonormally-constrained) rotation on the coefficients of the variables.

<!-- describe manip var path -->
For a radial tour fix the (horizontal) angle within the projection plane, $\theta$, and define a sequence for the (vertical) angle coming out of the projection plane, $\phi$, bringing the initial $XY$ contributions of the manip var to a maximum and then to zero before returning to the initial position. Dynamic capture of user manipulation is typically performed directly on the projection plane (without depiction of the manipulation space.)

Post-multiply the manipulation space by the pre-defined rotation matrix producing **RM**, the rotated manip space. This is one frame of basis values, repeat this procress for each value in the sequences of $\theta$ and $\phi$ for the complete animation.

Let:
\begin{itemize}
  \item[$c_\theta$] be the cosine of $\theta$
  \item[$c_\phi$]   be the cosine of $\phi$
  \item[$s_\theta$] be the sine of   $\theta$
  \item[$s_\phi$]   be the sine of   $\phi$
\end{itemize}

**For each value of ** $i$ **:**
<!-- don't mix rmd and latex... -->

\begin{align*}
  \textbf{RM}_{[p,~3,~i]}
  &= \textbf{M}_{[p,~3]} ~*~ \textbf{R}_{[3,~3,~i]} \\
  &= \textbf{M}_{[p,~3]}
    ~*~
  \begin{bmatrix}
    c_\theta^2 c_\phi s_\theta^2 &
    -c_\theta s_\theta (1 - c_\phi) &
    -c_\theta s_\phi \\
    -c_\theta s_\theta (1 - c_\phi) &
    s_\theta^2 c_\phi + c_\theta^2 &
    -s_\theta s_\phi \\
    c_\theta s_\phi &
    s_\theta s_\phi &
    c_\phi
  \end{bmatrix}_{[3,~3,~i]}
\end{align*}

<!--  phi transform and application note -->
A note on application: $\phi$ is the angle relative to the initial value of $\phi$, we find the transformation $\phi_i$ - $\phi_1$ useful to think about $\phi$ relative to the basis plane. Additionally, the value of $\phi$ may be out of phase by a factor of pi. If the manip variable doesn't move as expected these are the first places to check.

<!-- description of slides, on the technical side we haven't gone back to data space yet. -->
Figure \ref{fig:step3} illustrates a sequence with 15 projected bases, showing the reference axes on top the corresponding projected data points on the below. As a result, we can see that changes in the manip var controlled the distance between the purple cluster and the remaining sample, aede2 is crucial in distinguishing this species. Tours are typically viewed as an animation such a dynamic version of this tour can be viewed online at https://nspyrison.netlify.com/thesis/flea_manualtour_mvar5/. The page may take a moment to load. 

<!-- step3 caption -->


```{r step3, echo=F, warning=F, fig.height=7.2, fig.width=6, out.height='7.2in', out.width='6in',                                                                fig.cap = "Radial manual tour manipulating aede2 of standardized flea data.  The contributions increase from its initial contribution to a full contribution to the projection before decreasing to zero and then returning to its initial value. The change in the projected data shows that aede2 is important for distinguishing the purple species. An animated version can be viewed at  https://nspyrison.netlify.com/thesis/flea\\_manualtour\\_mvar5/."}
f_angle <- .26
f_mtour <- manual_tour(f_bas, manip_var = f_mvar, angle = f_angle)
if(dim(f_mtour)[3] != 15) message(
  paste0("!!!!! step3 n_slides != 15 !!!!! Please knit again. n_slides = ", dim(f_mtour)[3]))

#play_manual_tour(f_dat, f_bas, f_mvar, col = f_cat, angle = f_angle)
array2static(.m_tour = f_mtour, .data = f_dat, .m_var = f_mvar, .cat = f_cat)
```

Animations can be produced using the function `play_manual_tour()`. This function defaults to an HTML5 widget produced from **plotly**. The `render_type` argument can be changed to `render_gganimate` for exporting to GIF or MP4 files. 


# Data in projection-space {#sec:display}

<!-- the reminder of basis operation and now apply data -->
In an appeal to performance, the above operations are performed on the bases without the use of the larger datasets. After the bases are brought into the projection-space, however, it is helpful to observe them with data in the same space. Pre-multiply the data by basis frame bringing the data into the projection space.

\begin{align*}
  \textbf{P}_{[n,~3]} &= \textbf{X}_{[n,~p]} ~*~ \textbf{RM}_{[p,~3]}
\end{align*}

<!-- plot 2 var in seq for animation -->
For a 2D scatterplot, plot the first two variables from each frame statically as in the previous figure, or in sequence, producing an animated scatterplot. The remaining variable is sometimes linked to a data point aesthetic (such as size or color) to produce depth cues used in conjunction with the $XY$ scatterplot.

# Package structure and functionality {#sec:usage}

## Installation

<!-- step 0 disp code. -->
```{r installCODEEXAMPLE, eval=F, echo=T}
# remotes::install_github("nspyrison/spinifex") # Development version
install.package("spinifex")
library("spinifex")

# Also see the vignette: 
vignette("spinifex_vignette")
```

## Algorithm

We'll start by initializing values including: standardizing our data set (numeric coulmns only), provide a basis, a categorical variable for point asthetics, and specifiy the manip var. Then we the references axes of the basis with `view_basis()`.

<!-- setup -->
```{r step0CODEEXAMPLE, eval=F, echo=T}
f_data  <- tourr::rescale(flea[, 1:6])                    ## standardize data
f_path  <- save_history(f_data, guided_tour(holes()))     ## produce guided tour
f_basis <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2) ## end of guided tour
f_cat   <- factor(flea$species)                           ## categorical var

view_basis(basis = f_basis, 
           data = f_data,
           labels = colnames(f_data))
```

After becoming familar with the space, select a 

<!-- step 2 disp code. -->
```{r step2CODEEXAMPLE, eval=F, echo=T}
f_mvar  <- 5  ## manip var numebr

view_manip_space(basis = f_basis, 
                 manip_var = f_mvar, 
                 labels = colnames(f_data))
```

<!-- step 3 disp code. -->
```{r step3CODEEXAMPLE, eval=F, echo=T}
angle_speed <- .26

play_manual_tour(data = f_data,
                 basis = f_basis, 
                 manip_var = f_mvar, 
                 angle = angle_speed,
                 col = f_cat,
                 pch = f_cat)
```


## Walk though package functions in terms of work flow.



## Rendering and sharing

The **tourr** package utilizes **base** graphics for the display of tours. **spinifex** allows tours to be used in rendered in **plotly** as an HTML5 object or **gganimate** as GIF or MP4 files. Both of which build off **ggplot2** objects in internal functions. Sharing of animations is not trivial especially in print and static file formats such as PDF. Even with the use of computers and dynamic file formats capturing the correct resolution, aspect, and display is challenging and many formats quickly bloat file sizes. Keep in mind hosting options and exporting functions from **plotly**, **gganimate** and **tourr**.


## Storage

Storing each data point for every frame of the animation is redundant. Just as operations are performed on the bases, so too should tour paths be stored as bases and a single instance of the data. Consider a radial manual tour, we can store the salient features in 3 bases, where $\phi$ is at its starting, minimum, and maximum values. The frames in between can be interpolated by supplying angular speed. With the use of the `tourr::save_history()` function, the target bases can be saved. From there geodesic interpolation can be used to populate the intermittent frames. This type of interpolation should not be used on manual tours, which have already been initialized into a 3D manipulation space where direct linear interpolation is appropriate.


# Application {#sec:application}

<!-- Introduction of data and original paper -->
In a recent paper, @wang_mapping_2018, the authors aggregate and visualize the sensitivity of hadronic experiments to nucleon structure. The authors introduce a new tool, PDFSense, to aid in the visualization of Parton distribution functions (PDF). The parameter-space of these experiments lies in 56 dimensions, $\delta \in \mathbb{R}^{56}$, and are visualized as 3D subspaces of the 10 first principal components in linear (PCA) and non-linear (t-SNE) embeddings. 

<!-- grand tours on the same data -->
Using the same data, another study, @cook_dynamical_2018, applies grand tours [@asimov_grand_1985] to the same subspaces. Grand tours are dynamic subspace projections of high dimensional where frames and selected at random and linked with geodesically interpolation of the intermediate frames. Grand tours are able to better resolve the distribution shape of clusters, intra-cluster detail, and better outlier detection than the use of PDFSense & TFEP (TensorFlow embedded projections). Before applying manual tours let's discuss the structure of the data.

<!-- Data structure -->
The data has a hierarchical structure with top-level clusters; DIS, VBP, and jet. Each cluster is a particular class of experiments, each with many experimental datasets which, in turn, have many observations. In the consideration of data density, we conduct manual tours on subsets of the DIS and jet clusters. This explores the sensitivity of the structure to each of the variables in turn and we present the subjectively best and worst variable to manipulate for identifying dimensionality of the clusters and describing the span of the clusters.


## Jet cluster

<!-- jet cluster, explain dimensionality -->
The jet cluster resides in a smaller dimensionality than the full set of experiments with four principal components explaining 95% of the variation in the cluster [@cook_dynamical_2018]. The data within this 4D embedding is subset down to ATLAS7old and ATLAS7new to focus in on two groups with a reasonable number of observations that occupy different parts of the subspace. Radial manual tours controlling contributions from PC4 and PC3 are shown in figure \ref{fig:JetClusterGood} and figure \ref{fig:JetClusterBad} respectively. These components are selected to contrast the difference of information conveyed by touring different variables. Links to dynamic HTML5 animations controlling each of the four variables are also provided. 

<!-- discussion of findings and which is more insightful -->
When manipulating PC4, there is a clear difference in the parameter space spanned by the experiment types ATLAS7new and ATLAS7old. Yet, when PC3 is manipulated there is no indication that the different experiments probe different parameter space. Performing a radial manual tour on PC4 is more insightful than for PC3.

Radial manual tours manipulating each of the principal components in the jet cluster can be viewed by following the links: [PC1](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc1/), [PC2](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc2/), [PC3](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc3/), and [PC4](https://nspyrison.netlify.com/thesis/jetcluster_manualtour_pc4/).


```{r JetClusterGood, echo=F, warning=F, fig.height=7.2, fig.width=6, out.height='7.2in', out.width='6in',                                     fig.cap="A radial manual tour of PC4 within the jet cluster. Colored by experiment type: ATLAS7new in green and ATLAS7old in orange. When PC4 fully/negligibly contributes to the projection ATLAS7new (green) spans the same space as the orange points. During the intermediate frames, the ATLAS7new is compressed in the direction radial to PC4. A dynamic version can be viewed at https://nspyrison.netlify.com/thesis/jetcluster\\_manualtour\\_pc4/."}
# Jet cluster, Fig 7 of cook_dynamical_2018, subset to ATLAS7old and ATLAS7new
load("./data/JetCluster_sub.rda")
load("./data/JetCluster_basis.rda")

jet_bas   <- JetCluster_basis
jet_dat   <- tourr::rescale(JetCluster_sub[, 1:4])
jet_cat   <- factor(JetCluster_sub$exp)
jet_mvar  <- 4
jet_ang   <- .26
jet_mtour <- manual_tour(basis = jet_bas, manip_var = jet_mvar, angle = jet_ang)
#dim(jet_mtour)

array2static(.m_tour = jet_mtour, .data = jet_dat,
             .m_var = jet_mvar, .cat = jet_cat)
# play_manual_tour(data = jet_dat, basis = jet_bas, manip_var = jet_mvar,
#                  angle = jet_ang, axes = "bottomleft", col = jet_cat)

##M_VAR, RESULT
# 1, good
# 2, poor
# 3, *worst
# 4, *best
```


```{r JetClusterBad, echo=F, warning=F, fig.height=7.2, fig.width=6, out.height='7.2in', out.width='6in',                                       fig.cap = "A radial manual tour of PC4 within the jet cluster. Colored by experiment type: ATLAS7new in green and ATLAS7old in orange. Data from ATLAS7new (green) spans mostly the same space as ALTLAS7old (orange) with no evident difference in cluster structure across varying contributions of PC3. A dynamic version can be viewed at https://nspyrison.netlify.com/thesis/jetcluster\\_manualtour\\_pc3/."}
# Jet cluster, Fig 7 of cook_dynalical_2018, subset to ATLAS7old and ATLAS7new
jet_mvar  <- 3
jet_mtour <- manual_tour(basis = jet_bas, manip_var = jet_mvar, angle = jet_ang)

array2static(.m_tour = jet_mtour, .data = jet_dat,
             .m_var = jet_mvar, .cat = jet_cat)
```


## DIS cluster

<!-- introduce DIS cluster -->
A different space is used to explore the DIS cluster; specifically the first six principal components, which explains 48% of the variation contained within the aggregated data [@cook_dynamical_2018]. Radial manual tours are performed on PC6 and PC2 in figure \ref{fig:DISclusterGood} and figure \ref{fig:DISclusterBad} respectively.

<!-- comparison of the DIS cluster -->
The selection of the manip variable is important as the manipulation spaces convey substantially different information. The manual tour of PC6 offers information about the dimensionality, shape, and orientations of the different experiment classes. Whereas manipulating the contributions of PC2 only shows a subset of the dimensionality and shape information. Manipulating the contributions of PC6 turned out to be much more insightful than that of PC2. This result might seem counter-intuitive at first as PC2 should explain much more of the variation in the data. However, features and structure in the data regularly reside in finer detail that can be lost when looking only at static projections. 

DIS cluster manual tours manipulating each of the principal components can be viewed from the links: [PC1](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc1/), [PC2](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc2/), [PC3](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc3/), [PC4](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc4/), [PC5](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc5/), and [PC6](https://nspyrison.netlify.com/thesis/discluster_manualtour_pc6/).


```{r DISclusterGood, echo=F, warning=F, fig.height=7.2, fig.width=6, out.height='7.2in', out.width='6in',                                            fig.cap = "A radial manual tour manipulating the contribution of  PC6 within the DIS cluster. Points are colored by experiment type: DIS HERA1+2 in green, dimuon SIDIS in purple, and charm SIDIS in orange. The cluster DIS HERA1+2 (green) is distributed in a cross-shaped plane, charm SIDIS (orange) occupies the center space of this cross, with the plane projecting into the field of view when the contribution of PC6 is max. Less evident is the linear dimuon SIDIS (purple) observations approaching the line of view for intermediate values of PC6. A dynamic version can be viewed at https://nspyrison.netlify.com/thesis/discluster\\_manualtour\\_pc6/."}

##DIS cluster, fig 8 of cook_dynamical_2018
load("./data/grDIScenter.rda")
load("./data/DIScluster_centered_basis.rda")
DIS_bas   <- DIScluster_centered_basis
DIS_dat   <- tourr::rescale(grDIScenter[, 1:6])
DIS_cat   <- factor(grDIScenter$disID)
DIS_mvar  <- 6
DIS_ang   <- .27
DIS_mtour <- manual_tour(basis = DIS_bas, manip_var = DIS_mvar, angle = DIS_ang)

array2static(.m_tour = DIS_mtour, .data = DIS_dat,
             .m_var = DIS_mvar, .cat = DIS_cat)
# play_manual_tour(data = DIS_dat, basis = DIS_bas, manip_var = DIS_mvar,
#                  angle = DIS_ang, axes="bottomleft", col = DIS_cat)

##M_VAR, RESULT
# 1, purple jet
# 2, *poor
# 3, black
# 4, plane
# 5, black and plane
# 6, best*purple and plane
```


```{r DISclusterBad, echo=F, warning=F, fig.height=7.2, fig.width=6, out.height='7.2in', out.width='6in',                                            fig.cap = "A radial manual tour manipulating the contribution of PC2 within the DIS cluster. Points are colored by experiment type: DIS HERA1+2 in green, dimuon SIDIS in purple, and charm SIDIS in orange. The plane of cross distributed DIS HERA data (green) and a nearly orthogonal jet of dimuon SIDIS (purple) is present. This jet does extend more in the plane of view when the contribution of PC2 is full, giving insight to its orientation. However, less information about the shape of DIS HERA (green) and charm SIDIS (orange) is available. A dynamic version can be viewed at https://nspyrison.netlify.com/thesis/discluster\\_manualtour\\_pc2/."}
##DIS cluster, fig 8 of cook_dynamical_2018
DIS_mvar  <- 2
DIS_mtour <- manual_tour(basis = DIS_bas, manip_var = DIS_mvar, angle = DIS_ang)

array2static(.m_tour = DIS_mtour, .data = DIS_dat,
             .m_var = DIS_mvar, .cat = DIS_cat)
```


## Summary

<!-- summary and segue  -->
Tours, which are dynamic linear projection of multivariate data, play an important role in data visualization; they extend the dimensionality of visuals while data- and parameter-spaces become ever larger. This research has modified the algorithm producing manual tours which and has made this functionality available in package **spinifex**. The package adds to **tourr**, extending the graphics offerings that can be used to display tours.

Radial manual tours were applied to a dataset across different experiments of hadronic collisions. The importance of selecting the correct variable to manipulate is demonstrated by comparing tours of varying quality. The manual tours convey a better picture of the structure of the clustering than static linear or non-linear projections. Giving the full contribution of the manipulation space to the manip var enables analysts to explore the sensitivity of the structure with the selected variable. This information can be used by physicists to identify which experiments are probing which parameter spaces, which can be indispensable for smarter planning of effort and funding.


# Discussion {#sec:discussion}

<!-- 3D and function vis -->
Future research on the algorithm would include extending it for use in 3D projections. The addition of another dimension theoretically allows for improved perception. This could explore interactions in immersive virtual reality or mixed reality, which may further allow for a better perception of structure and aid in higher-dimensional function visualization. Functions with many parameters suffer from the same dimensionality problem as data while their possible values lie on a plane of values rather than discrete points. Occulation, or the closer surface blocking further surfaces, will likely be an issue that may be alleviated by the use of wire mesh, changing opacity, or looking at sections of the projections [@furnas_prosection_1994].

<!-- geometric and graphics display -->
The **tourr** package provides many other geometric displays with the `tourr::display_*()` family. These geometric options could be integrated into the **ggplot2** framework for display on **plotly** and **gganimate**. Additionally, the \CRANpkg{animation} package @xie_animation:_2018 could be implemented for another graphics framework. However, **animation** builds from **base** graphics while **spinifex** utilizes **ggplot2** graphics, a significant paradigm shift.

<!-- interpolation -->
The Givens rotations and Householder reflections as outlined in @buja_computational_2005 could also be added. Currently, Gram-Schmidt is the only form of frame interpolation used (not used in manual tours). In a Givens rotation, the $x$ and $y$ components (for example $\theta~= 0,~pi/2$) of the in-plane rotation are calculated separately and would be applied sequentially to produce the radial rotation. Householder reflections define reflection axes to project points on to the axes and generate rotations.

<!-- dynamic interaction/gui -->
Having a script only interaction with tours causes a significant barrier to entry. To a lesser extent, **plotly** offers some static interactions with the contained object, such as tooltips, brushing, and linking without communicating back to the R console. The development of a dynamic graphical user interface, perhaps with the use of a \CRANpkg{shiny} [@chang_shiny:_2018] application, would mitigate the barrier to entry, allow for more rapid analysis, and offer an approachable demo tool. The user could easily switch between variables to control, adjust interpolation step angle, or flag/save specific frame basis sets. 

# Acknowledgments

This article was created in R [@r_core_team_r:_2018], using \CRANpkg{knitr} [@stodden_knitr:_2014] and \CRANpkg{rmarkdown} [@xie_r_2018], with code generating the examples inline. The source files for this article be found at [github.com/nspyrison/spinifex_paper/](https://github.com/nspyrison/spinifex_paper/). The source code for the **spinifex** package can be found at [github.com/nspyrison/spinifex/](https://github.com/nspyrison/spinifex/).


# Bibliography

